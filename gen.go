package bebop

import (
	"encoding/binary"
	"fmt"
	"io"
	"sort"
	"strconv"
	"strings"
	"time"
)

type GenerateSettings struct {
	PackageName string

	typeMarshallers          map[string]string
	typeUnmarshallers        map[string]string
	messageTypeUnmarshallers map[string]string
	typeLengthers            map[string]string
	customRecordTypes        map[string]struct{}
}

func (f File) Validate() error {
	// TODO: check no user defined type name is the same as a primitive (or reserved, like map/array/struct)
	// TODO: check no duplicate type names are defined
	// TODO: check that all types make sense (are primitive, or exist in the file)
	// TODO: importing other files? oh god
	return nil
}

func (f File) Generate(w io.Writer, settings GenerateSettings) error {
	if err := f.Validate(); err != nil {
		return fmt.Errorf("cannot generate file: %w", err)
	}
	settings.typeMarshallers = f.typeMarshallers()
	settings.typeUnmarshallers = f.typeUnmarshallers()
	settings.typeLengthers = f.typeLengthers()
	settings.customRecordTypes = f.customRecordTypes()

	writeLine(w, "// Code generated by bebopc-go; DO NOT EDIT.")
	writeLine(w, "")
	writeLine(w, "package %s", settings.PackageName)
	writeLine(w, "")
	writeLine(w, "import (")
	if len(f.Messages) != 0 {
		writeLine(w, "\t\"bytes\"")
	}
	if len(f.Messages)+len(f.Structs) != 0 {
		writeLine(w, "\t\"encoding/binary\"")
	}
	if len(f.Messages)+len(f.Structs) != 0 {
		writeLine(w, "\t\"io\"")
	}
	if f.hasDateType() {
		writeLine(w, "\t\"time\"")
	}
	writeLine(w, "")
	if len(f.Messages)+len(f.Structs) != 0 {
		writeLine(w, "\t\"github.com/200sc/bebop\"")
	}
	writeLine(w, ")")
	writeLine(w, "")

	for _, en := range f.Enums {
		en.Generate(w, settings)
	}
	for _, st := range f.Structs {
		st.Generate(w, settings)
	}
	for _, msg := range f.Messages {
		msg.Generate(w, settings)
	}
	return nil
}

func writeLine(w io.Writer, format string, args ...interface{}) {
	fmt.Fprintf(w, format+"\n", args...)
}

func writeLineWithTabs(w io.Writer, format string, depth int, args ...string) {
	// Index 0: none, fmt is 1-indexed
	// Index 1: tabs
	// Index 2:	the name to read from
	// Index 3: the name to assign to
	// At the final index we have the original name in non-pointer form for decoding
	if len(args) != 0 {
		if args[0][0] == '&' || args[0][0] == '*' {
			args = append(args, args[0][1:])
		} else {
			args = append(args, "*"+args[0])
		}
	}

	// add tabs
	tbs := strings.Repeat("\t", depth)
	args = append([]string{tbs}, args...)
	format = "%[1]s" + format
	format = strings.Replace(format, "\n", "\n%[1]s", -1)

	ifArgs := make([]interface{}, len(args))
	for i, arg := range args {
		ifArgs[i] = arg
	}
	fmt.Fprintf(w, format+"\n", ifArgs...)
}

func (en Enum) Generate(w io.Writer, settings GenerateSettings) {
	exposedName := exposeName(en.Name)
	if en.Comment != "" {
		writeLine(w, "// %s", en.Comment)
	}
	writeLine(w, "type %s uint32", exposedName)
	writeLine(w, "")
	writeLine(w, "const (")
	for _, opt := range en.Options {
		if opt.Comment != "" {
			writeLine(w, "\t// %s", opt.Comment)
		}
		if opt.Deprecated {
			writeLine(w, "\t// Deprecated: %s", opt.DeprecatedMessage)
		}
		writeLine(w, "\t%s_%s %s = %d", exposedName, opt.Name, exposedName, opt.Value)
	}
	writeLine(w, ")")
	writeLine(w, "")
}

func (st Struct) Generate(w io.Writer, settings GenerateSettings) {
	exposedName := exposeName(st.Name)
	if st.OpCode != 0 {
		writeLine(w, "const %sOpCode = 0x%x", exposedName, st.OpCode)
		writeLine(w, "")
	}
	if st.Comment != "" {
		writeLine(w, "// %s", st.Comment)
	}
	writeLine(w, "var _ bebop.Record = &%s{}", exposedName)
	writeLine(w, "")
	writeLine(w, "type %s struct {", exposedName)
	for _, fd := range st.Fields {
		writeFieldDefinition(fd, w, settings, st.ReadOnly, false)
	}
	writeLine(w, "}")
	writeLine(w, "")
	writeLine(w, "func(bbp %s) EncodeBebop(w io.Writer) (err error) {", exposedName)
	if st.OpCode != 0 {
		writeLine(w, "\tbinary.Write(w, binary.LittleEndian, uint32(%sOpCode))", exposedName)
	}
	for _, fd := range st.Fields {
		name := exposeName(fd.Name)
		if st.ReadOnly {
			name = unexposeName(fd.Name)
		}
		writeStructFieldMarshaller("bbp."+name, fd.FieldType, w, settings, 1)
	}
	writeLine(w, "\treturn nil")
	writeLine(w, "}")
	writeLine(w, "")
	writeLine(w, "func(bbp *%s) DecodeBebop(r io.Reader) (err error) {", exposedName)
	if st.hasLengthedType() {
		writeLine(w, "\tvar ln uint32")
	}
	if st.OpCode != 0 {
		writeLine(w, "\tr.Read(make([]byte, 4))")
	}
	for _, fd := range st.Fields {
		name := exposeName(fd.Name)
		if st.ReadOnly {
			name = unexposeName(fd.Name)
		}
		writeStructFieldUnmarshaller("&bbp."+name, fd.FieldType, w, settings, 1)
	}
	writeLine(w, "\treturn nil")
	writeLine(w, "}")
	writeLine(w, "")
	writeLine(w, "func(bbp *%s) bodyLen() (uint32) {", exposedName)
	writeLine(w, "\tbodyLen := uint32(0)")
	for _, fd := range st.Fields {
		name := exposeName(fd.Name)
		if st.ReadOnly {
			name = unexposeName(fd.Name)
		}
		name = "bbp." + name
		writeMessageFieldBodyCount(name, fd.FieldType, w, settings, 1)
	}
	writeLine(w, "\treturn bodyLen")
	writeLine(w, "}")
	writeLine(w, "")

	// TODO: slices are not really readonly, we need to return a copy.
	if st.ReadOnly {
		for _, fd := range st.Fields {
			writeLine(w, "func (bbp %s) Get%s() %s {", exposedName, exposeName(fd.Name), fd.FieldType.GoString())
			writeLine(w, "\treturn bbp.%s", unexposeName(fd.Name))
			writeLine(w, "}")
			writeLine(w, "")
		}
	}
}

type FieldWithNumber struct {
	Field
	num uint8
}

func (msg Message) Generate(w io.Writer, settings GenerateSettings) {
	exposedName := exposeName(msg.Name)
	if msg.OpCode != 0 {
		writeLine(w, "const %sOpCode = 0x%x", exposedName, msg.OpCode)
		writeLine(w, "")
	}
	if msg.Comment != "" {
		writeLine(w, "// %s", msg.Comment)
	}
	writeLine(w, "var _ bebop.Record = &%s{}", exposedName)
	writeLine(w, "")
	writeLine(w, "type %s struct {", exposedName)
	fields := make([]FieldWithNumber, 0, len(msg.Fields))
	for i, fd := range msg.Fields {
		fields = append(fields, FieldWithNumber{
			Field: fd,
			num:   i,
		})
	}
	sort.Slice(fields, func(i, j int) bool {
		return fields[i].num < fields[j].num
	})
	for _, fd := range fields {
		writeFieldDefinition(fd.Field, w, settings, msg.ReadOnly, true)
	}
	writeLine(w, "}")
	writeLine(w, "")
	writeLine(w, "func(bbp %s) EncodeBebop(w io.Writer) (err error) {", exposedName)
	writeLine(w, "\tbinary.Write(w, binary.LittleEndian, bbp.bodyLen())")
	for _, fd := range fields {
		name := exposeName(fd.Name)
		if msg.ReadOnly {
			name = unexposeName(fd.Name)
		}
		num := strconv.Itoa(int(fd.num))
		name = "*bbp." + name
		writeLineWithTabs(w, "if %[3]s != nil {", 1, name)
		writeLineWithTabs(w, "w.Write([]byte{%[2]s})", 2, num)
		writeMessageFieldMarshaller(name, fd.FieldType, w, settings, 2)
		writeLineWithTabs(w, "}", 1)
	}
	writeLine(w, "\tw.Write([]byte{0})")
	writeLine(w, "\treturn nil")
	writeLine(w, "}")
	writeLine(w, "")
	writeLine(w, "func(bbp *%s) DecodeBebop(ior io.Reader) (err error) {", exposedName)
	if msg.hasLengthedType() {
		writeLine(w, "\tvar ln uint32")
	}
	writeLine(w, "\tvar bodyLen uint32")
	writeLine(w, "\tvar fieldNum byte")
	writeLine(w, "\tbinary.Read(ior, binary.LittleEndian, &bodyLen)")
	writeLine(w, "\tbody := make([]byte, bodyLen)")
	writeLine(w, "\tior.Read(body)")
	writeLine(w, "\tr := bytes.NewReader(body)")
	writeLine(w, "\tfor r.Len() > 1 {")
	writeLine(w, "\t\tfieldNum, _ = r.ReadByte()")
	writeLine(w, "\t\tswitch fieldNum {")
	for _, fd := range fields {
		writeLine(w, "\t\tcase %d:", fd.num)
		name := exposeName(fd.Name)
		if msg.ReadOnly {
			name = unexposeName(fd.Name)
		}
		writeLine(w, "\t\t\tbbp.%[1]s = new(%[2]s)", name, fd.FieldType.GoString())
		writeMessageFieldUnmarshaller("bbp."+name, fd.FieldType, w, settings, 3)
	}
	// ref: https://github.com/RainwayApp/bebop/wiki/Wire-format#messages, final paragraph
	// for some reason we're allowed to skip parsing all remaining fields if we see one
	// that we don't know about.
	writeLine(w, "\t\tdefault:")
	writeLine(w, "\t\t\treturn nil")
	writeLine(w, "\t\t}")
	writeLine(w, "\t}")
	writeLine(w, "\treturn nil")
	writeLine(w, "}")
	writeLine(w, "")
	writeLine(w, "func(bbp *%s) bodyLen() (uint32) {", exposedName)
	writeLine(w, "\tbodyLen := uint32(1)")
	for _, fd := range fields {
		name := exposeName(fd.Name)
		if msg.ReadOnly {
			name = unexposeName(fd.Name)
		}
		name = "*bbp." + name
		writeLineWithTabs(w, "if %[3]s != nil {", 1, name)
		writeLineWithTabs(w, "bodyLen += 1", 2)
		writeMessageFieldBodyCount(name, fd.FieldType, w, settings, 2)
		writeLineWithTabs(w, "}", 1)
	}
	writeLine(w, "\treturn bodyLen")
	writeLine(w, "}")
	writeLine(w, "")

	// TODO: decode method
	if msg.ReadOnly {
		for _, fd := range msg.Fields {
			writeLine(w, "func (bbp %s) Get%s() *%s {", exposedName, exposeName(fd.Name), fd.FieldType.GoString())
			writeLine(w, "\treturn bbp.%s", unexposeName(fd.Name))
			writeLine(w, "}")
			writeLine(w, "")
		}
	}
}

func writeFieldDefinition(fd Field, w io.Writer, settings GenerateSettings, readOnly bool, message bool) {
	if fd.Comment != "" {
		writeLine(w, "\t// %s", fd.Comment)
	}
	if fd.Deprecated {
		writeLine(w, "\t// Deprecated: %s", fd.DeprecatedMessage)
	}

	name := exposeName(fd.Name)
	if readOnly {
		name = unexposeName(fd.Name)
	}
	typ := fd.FieldType.GoString()
	if message {
		typ = "*" + typ
	}
	writeLine(w, "\t%s %s", name, typ)
}

func writeStructFieldMarshaller(name string, typ FieldType, w io.Writer, settings GenerateSettings, depth int) {
	if typ.Array != nil {
		writeLineWithTabs(w, "binary.Write(w, binary.LittleEndian, uint32(len(%[2]s)))", depth, name)
		writeLineWithTabs(w, "for _, elem := range %[2]s {", depth, name)
		writeStructFieldMarshaller("elem", *typ.Array, w, settings, depth+1)
		writeLineWithTabs(w, "}", depth)
	} else if typ.Map != nil {
		writeLineWithTabs(w, "binary.Write(w, binary.LittleEndian, uint32(len(%[2]s)))", depth, name)
		writeLineWithTabs(w, "for k, v := range %[2]s {", depth, name)
		writeLineWithTabs(w, settings.typeMarshallers[typ.Map.Key], depth+1, "k")
		writeStructFieldMarshaller("v", typ.Map.Value, w, settings, depth+1)
		writeLineWithTabs(w, "}", depth)
	} else {
		writeLineWithTabs(w, settings.typeMarshallers[typ.Simple], depth, name)
	}
}

func writeStructFieldUnmarshaller(name string, typ FieldType, w io.Writer, settings GenerateSettings, depth int) {
	elemName := "elem" + strconv.Itoa(depth)
	if typ.Array != nil {
		writeLineWithTabs(w, "ln = uint32(0)", depth)
		writeLineWithTabs(w, "binary.Read(r, binary.LittleEndian, &ln)", depth, name)
		writeLineWithTabs(w, "for i := uint32(0); i < ln; i++ {", depth, name)
		writeLineWithTabs(w, elemName+" := new(%[2]s)", depth+1, typ.Array.GoString())
		writeStructFieldUnmarshaller(elemName, *typ.Array, w, settings, depth+1)
		writeLineWithTabs(w, "%[3]s = append(%[3]s, *"+elemName+")", depth+1, name)
		writeLineWithTabs(w, "}", depth)
	} else if typ.Map != nil {
		writeLineWithTabs(w, "ln = uint32(0)", depth)
		writeLineWithTabs(w, "binary.Read(r, binary.LittleEndian, &ln)", depth, name)
		writeLineWithTabs(w, "%[3]s = make("+typ.Map.GoString()+")", depth, name)
		writeLineWithTabs(w, "for i := uint32(0); i < ln; i++ {", depth, name)
		writeLineWithTabs(w, "k := new("+simpleGoString(typ.Map.Key)+")", depth+1, name)
		writeLineWithTabs(w, settings.messageTypeUnmarshaller(typ.Map.Key), depth+1, "k")
		writeLineWithTabs(w, elemName+" := new(%[2]s)", depth+1, typ.Map.Value.GoString())
		writeStructFieldUnmarshaller(elemName, typ.Map.Value, w, settings, depth+1)
		writeLineWithTabs(w, "(%[3]s)[*k] = *"+elemName, depth+1, name)
		writeLineWithTabs(w, "}", depth)
	} else {
		writeLineWithTabs(w, settings.messageTypeUnmarshaller(typ.Simple), depth, name)
	}
}

func writeMessageFieldMarshaller(name string, typ FieldType, w io.Writer, settings GenerateSettings, depth int) {
	if typ.Array != nil {
		writeLineWithTabs(w, "binary.Write(w, binary.LittleEndian, uint32(len(%[2]s)))", depth, name)
		writeLineWithTabs(w, "for _, elem := range %[2]s {", depth, name)
		writeMessageFieldMarshaller("elem", *typ.Array, w, settings, depth+1)
		writeLineWithTabs(w, "}", depth)
	} else if typ.Map != nil {
		writeLineWithTabs(w, "binary.Write(w, binary.LittleEndian, uint32(len(%[2]s)))", depth, name)
		writeLineWithTabs(w, "for k, v := range %[2]s {", depth, name)
		writeLineWithTabs(w, settings.typeMarshallers[typ.Map.Key], depth+1, "k")
		writeMessageFieldMarshaller("v", typ.Map.Value, w, settings, depth+1)
		writeLineWithTabs(w, "}", depth)
	} else {
		writeLineWithTabs(w, settings.typeMarshallers[typ.Simple], depth, name)
	}
}

func (s GenerateSettings) messageTypeUnmarshaller(typ string) string {
	if v, ok := s.messageTypeUnmarshallers[typ]; ok {
		return v
	}
	return s.typeUnmarshallers[typ]
}

func typeNeedsElem(typ string, settings GenerateSettings) bool {
	switch typ {
	case "":
		return true
	case "string":
		return true
	}
	if _, ok := primitiveTypes[typ]; ok {
		return false
	}
	_, ok := settings.customRecordTypes[typ]
	return ok
}

func writeMessageFieldBodyCount(name string, typ FieldType, w io.Writer, settings GenerateSettings, depth int) {
	if typ.Array != nil {
		writeLineWithTabs(w, "bodyLen += 4", depth)
		if typeNeedsElem(typ.Array.Simple, settings) {
			writeLineWithTabs(w, "for _, elem := range %[2]s {", depth, name)
		} else {
			writeLineWithTabs(w, "for _ = range %[2]s {", depth, name)
		}
		writeMessageFieldBodyCount("elem", *typ.Array, w, settings, depth+1)
		writeLineWithTabs(w, "}", depth)
	} else if typ.Map != nil {
		writeLineWithTabs(w, "bodyLen += 4", depth, name)
		useV := typeNeedsElem(typ.Map.Value.Simple, settings)
		useK := typ.Map.Key == "string"
		if useV && useK {
			writeLineWithTabs(w, "for k, v := range %[2]s {", depth, name)
		} else if useV {
			writeLineWithTabs(w, "for _, v := range %[2]s {", depth, name)
		} else if useK {
			writeLineWithTabs(w, "for k := range %[2]s {", depth, name)
		} else {
			writeLineWithTabs(w, "for _ = range %[2]s {", depth, name)
		}
		writeLineWithTabs(w, settings.typeLengthers[typ.Map.Key], depth+1, "k")
		writeMessageFieldBodyCount("v", typ.Map.Value, w, settings, depth+1)
		writeLineWithTabs(w, "}", depth)
	} else {
		writeLineWithTabs(w, settings.typeLengthers[typ.Simple], depth, name)
	}
}

func writeMessageFieldUnmarshaller(name string, typ FieldType, w io.Writer, settings GenerateSettings, depth int) {
	if typ.Array != nil {
		writeLineWithTabs(w, "ln = uint32(0)", depth)
		writeLineWithTabs(w, "binary.Read(r, binary.LittleEndian, &ln)", depth, name)
		writeLineWithTabs(w, "for i := uint32(0); i < ln; i++ {", depth, name)
		writeLineWithTabs(w, "elem := new(%[2]s)", depth+1, typ.Array.GoString())
		writeMessageFieldUnmarshaller("elem", *typ.Array, w, settings, depth+1)
		writeLineWithTabs(w, "}", depth)
	} else if typ.Map != nil {
		writeLineWithTabs(w, "ln = uint32(0)", depth)
		writeLineWithTabs(w, "binary.Read(r, binary.LittleEndian, &ln)", depth, name)
		writeLineWithTabs(w, "%[3]s = make("+typ.Map.GoString()+")", depth, name)
		writeLineWithTabs(w, "for i := uint32(0); i < ln; i++ {", depth, name)
		writeLineWithTabs(w, "var k "+simpleGoString(typ.Map.Key), depth+1, name)
		writeLineWithTabs(w, settings.typeUnmarshallers[typ.Map.Key], depth+1, "k")
		writeLineWithTabs(w, "elem := new(%[2]s)", depth+1, typ.Map.Value.GoString())
		writeMessageFieldUnmarshaller("elem", typ.Map.Value, w, settings, depth+1)
		writeLineWithTabs(w, "}", depth)
	} else {
		writeLineWithTabs(w, settings.typeUnmarshallers[typ.Simple], depth, name)
	}
}

func exposeName(name string) string {
	if len(name) > 1 {
		return strings.ToUpper(string(name[0])) + name[1:]
	}
	if len(name) > 0 {
		return strings.ToUpper(string(name[0]))
	}
	return ""
}

func unexposeName(name string) string {
	if len(name) > 1 {
		return strings.ToLower(string(name[0])) + name[1:]
	}
	if len(name) > 0 {
		return strings.ToLower(string(name[0]))
	}
	return ""
}

func (f File) messageTypeUnmarshallers() map[string]string {
	out := make(map[string]string)
	out["guid"] = "%[3]s = bebop.ReadGUID(r)"
	return out
}

func (f File) typeUnmarshallers() map[string]string {
	out := make(map[string]string)
	out["bool"] = "binary.Read(r, binary.LittleEndian, %[2]s)"
	out["byte"] = "binary.Read(r, binary.LittleEndian, %[2]s)"
	out["uint8"] = out["byte"]
	out["uint16"] = "binary.Read(r, binary.LittleEndian, %[2]s)"
	out["int16"] = "binary.Read(r, binary.LittleEndian, %[2]s)"
	out["uint32"] = "binary.Read(r, binary.LittleEndian, %[2]s)"
	out["int32"] = "binary.Read(r, binary.LittleEndian, %[2]s)"
	out["uint64"] = "binary.Read(r, binary.LittleEndian, %[2]s)"
	out["int64"] = "binary.Read(r, binary.LittleEndian, %[2]s)"
	// TODO: check floats
	out["float32"] = "binary.Read(r, binary.LittleEndian, %[2]s)"
	out["float64"] = "binary.Read(r, binary.LittleEndian, %[2]s)"
	out["string"] = "%[3]s = bebop.ReadString(r)"
	// TODO: we have to do whatever .NET does for uuids
	out["guid"] = "%[3]s = bebop.ReadGUID(r)"
	out["date"] = "%[3]s = bebop.ReadTime(r)"
	for _, en := range f.Enums {
		out[en.Name] = "binary.Read(r, binary.LittleEndian, %[2]s)"
	}
	for _, st := range f.Structs {
		format := "err = (%[2]s).DecodeBebop(r)\n" +
			"if err != nil {\n" +
			"\treturn err\n" +
			"}"
		out[st.Name] = format
	}
	for _, msg := range f.Messages {
		format := "err = (%[2]s).DecodeBebop(r)\n" +
			"if err != nil {\n" +
			"\treturn err\n" +
			"}"
		out[msg.Name] = format
	}
	return out
}

func (f File) typeMarshallers() map[string]string {
	out := make(map[string]string)
	out["bool"] = "binary.Write(w, binary.LittleEndian, %[2]s)"
	out["byte"] = "binary.Write(w, binary.LittleEndian, %[2]s)"
	out["uint8"] = out["byte"]
	out["uint16"] = "binary.Write(w, binary.LittleEndian, %[2]s)"
	out["int16"] = "binary.Write(w, binary.LittleEndian, %[2]s)"
	out["uint32"] = "binary.Write(w, binary.LittleEndian, %[2]s)"
	out["int32"] = "binary.Write(w, binary.LittleEndian, %[2]s)"
	out["uint64"] = "binary.Write(w, binary.LittleEndian, %[2]s)"
	out["int64"] = "binary.Write(w, binary.LittleEndian, %[2]s)"
	// TODO: check floats
	out["float32"] = "binary.Write(w, binary.LittleEndian, %[2]s)"
	out["float64"] = "binary.Write(w, binary.LittleEndian, %[2]s)"
	out["string"] = "binary.Write(w, binary.LittleEndian, uint32(len(%[2]s)))\n" +
		"w.Write([]byte(%[2]s))"
	// TODO: we have to do whatever .NET does for uuids
	out["guid"] = "w.Write(%[2]s[:])"
	out["date"] = "if %[2]s != (time.Time{}) {\n" +
		"\tbinary.Write(w, binary.LittleEndian, (%[2]s.UnixNano()/100))\n" +
		"} else {\n" +
		"\tbinary.Write(w, binary.LittleEndian, int64(0))\n" +
		"}"
	for _, en := range f.Enums {
		out[en.Name] = "binary.Write(w, binary.LittleEndian, uint32(%[2]s))"
	}
	for _, st := range f.Structs {
		format := "err = (%[2]s).EncodeBebop(w)\n" +
			"if err != nil {\n" +
			"\treturn err\n" +
			"}"
		out[st.Name] = format
	}
	for _, msg := range f.Messages {
		format := "err = (%[2]s).EncodeBebop(w)\n" +
			"if err != nil {\n" +
			"\treturn err\n" +
			"}"
		out[msg.Name] = format
	}
	return out
}

func (f File) typeLengthers() map[string]string {
	out := make(map[string]string)
	out["bool"] = "bodyLen += 1"
	out["byte"] = "bodyLen += 1"
	out["uint8"] = out["byte"]
	out["uint16"] = "bodyLen += 2"
	out["int16"] = "bodyLen += 2"
	out["uint32"] = "bodyLen += 4"
	out["int32"] = "bodyLen += 4"
	out["uint64"] = "bodyLen += 8"
	out["int64"] = "bodyLen += 8"
	// TODO: check float encoding
	out["float32"] = "bodyLen += 4"
	out["float64"] = "bodyLen += 8"
	out["string"] = "bodyLen += 4\n" + "bodyLen += uint32(len(%[2]s))"
	// TODO: we have to do whatever .NET does for uuids
	out["guid"] = "bodyLen += 16"
	out["date"] = "bodyLen += 8"
	for _, en := range f.Enums {
		out[en.Name] = "bodyLen += 4"
	}
	for _, st := range f.Structs {
		format := "bodyLen += (%[2]s).bodyLen()"
		out[st.Name] = format
	}
	for _, msg := range f.Messages {
		format := "bodyLen += (%[2]s).bodyLen()"
		out[msg.Name] = format
	}
	return out
}

func (f File) customRecordTypes() map[string]struct{} {
	out := make(map[string]struct{})
	for _, st := range f.Structs {
		out[st.Name] = struct{}{}
	}
	for _, msg := range f.Messages {
		out[msg.Name] = struct{}{}
	}
	return out
}

func (f File) hasDateType() bool {
	for _, st := range f.Structs {
		for _, fd := range st.Fields {
			if fd.FieldType.hasDateType() {
				return true
			}
		}
	}
	for _, msg := range f.Messages {
		for _, fd := range msg.Fields {
			if fd.FieldType.hasDateType() {
				return true
			}
		}
	}
	return false
}

func (ft FieldType) hasDateType() bool {
	if ft.Simple == "date" {
		return true
	}
	if ft.Array != nil {
		return ft.Array.hasDateType()
	}
	if ft.Map != nil {
		if ft.Map.Key == "date" {
			return true
		}
		return ft.Map.Value.hasDateType()
	}
	return false
}

func (st Struct) hasLengthedType() bool {
	for _, fd := range st.Fields {
		if fd.FieldType.hasLengthedType() {
			return true
		}
	}
	return false
}

func (msg Message) hasLengthedType() bool {
	for _, fd := range msg.Fields {
		if fd.FieldType.hasLengthedType() {
			return true
		}
	}
	return false
}

func (ft FieldType) hasLengthedType() bool {
	if ft.Array != nil {
		return true
	}
	if ft.Map != nil {
		return true
	}
	return false
}

func ReadString(r io.Reader) string {
	ln := uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	data := make([]byte, ln)
	r.Read(data)
	return string(data)
}

func ReadTime(r io.Reader) time.Time {
	tm := int64(0)
	binary.Read(r, binary.LittleEndian, (&tm))
	tm *= 100
	t := time.Time{}
	if tm == 0 {
		return t
	}
	return time.Unix(0, tm).UTC()
}

func ReadGUID(r io.Reader) [16]byte {
	data := make([]byte, 16)
	r.Read(data)
	arr := [16]byte{}
	copy(arr[:], data[:16])
	return arr
}
