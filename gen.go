package bebop

import (
	"encoding/binary"
	"fmt"
	"io"
	"sort"
	"strings"
)

type GenerateSettings struct {
	PackageName string

	typeMarshallers   map[string]string
	typeUnmarshallers map[string]string
}

func (f File) Validate() error {
	// TODO: check no user defined type name is the same as a primitive (or reserved, like map/array/struct)
	// TODO: check no duplicate type names are defined
	// TODO: check that all types make sense (are primitive, or exist in the file)
	// TODO: importing other files? oh god
	return nil
}

func (f File) Generate(w io.Writer, settings GenerateSettings) error {
	if err := f.Validate(); err != nil {
		return fmt.Errorf("cannot generate file: %w", err)
	}
	settings.typeMarshallers = f.typeMarshallers()
	settings.typeUnmarshallers = f.typeUnmarshallers()

	writeLine(w, "// Code generated by bebopc-go; DO NOT EDIT.")
	writeLine(w, "")
	writeLine(w, "package %s", settings.PackageName)
	writeLine(w, "")
	writeLine(w, "import (")
	writeLine(w, "\t\"encoding/binary\"")
	writeLine(w, "\t\"io\"")
	if f.hasDateType() {
		writeLine(w, "\t\"time\"")
	}
	writeLine(w, "")
	writeLine(w, "\t\"github.com/200sc/bebop\"")
	writeLine(w, ")")
	writeLine(w, "")

	for _, en := range f.Enums {
		en.Generate(w, settings)
	}
	for _, st := range f.Structs {
		st.Generate(w, settings)
	}
	for _, msg := range f.Messages {
		msg.Generate(w, settings)
	}
	return nil
}

func writeLine(w io.Writer, format string, args ...interface{}) {
	fmt.Fprintf(w, format+"\n", args...)
}

func writeLineWithTabs(w io.Writer, format string, depth int, args ...string) {
	tbs := strings.Repeat("\t", depth)
	args = append(args, tbs)
	// At the final index we have the original name in non-pointer form for decoding
	if args[0][0] == '&' || args[0][0] == '*' {
		args = append(args, args[0][1:])
	} else {
		args = append(args, "*"+args[0])
	}
	ifArgs := make([]interface{}, len(args))
	for i, arg := range args {
		ifArgs[i] = arg
	}
	fmt.Fprintf(w, format+"\n", ifArgs...)
}

func (en Enum) Generate(w io.Writer, settings GenerateSettings) {
	exposedName := exposeName(en.Name)
	if en.Comment != "" {
		writeLine(w, "// %s", en.Comment)
	}
	writeLine(w, "type %s uint32", exposedName)
	writeLine(w, "")
	writeLine(w, "const (")
	for _, opt := range en.Options {
		if opt.Comment != "" {
			writeLine(w, "\t// %s", opt.Comment)
		}
		if opt.Deprecated {
			writeLine(w, "\t// Deprecated: %s", opt.DeprecatedMessage)
		}
		writeLine(w, "\t%s_%s %s = %d", exposedName, opt.Name, exposedName, opt.Value)
	}
	writeLine(w, ")")
	writeLine(w, "")
}

func (st Struct) Generate(w io.Writer, settings GenerateSettings) {
	exposedName := exposeName(st.Name)
	if st.OpCode != 0 {
		writeLine(w, "const %sOpCode = 0x%x", exposedName, st.OpCode)
		writeLine(w, "")
	}
	if st.Comment != "" {
		writeLine(w, "// %s", st.Comment)
	}
	writeLine(w, "type %s struct {", exposedName)
	for _, fd := range st.Fields {
		writeFieldDefinition(fd, w, settings, st.ReadOnly, false)
	}
	writeLine(w, "}")
	writeLine(w, "")
	writeLine(w, "func(bbp %s) EncodeBebop(w io.Writer) (err error) {", exposedName)
	if len(st.Fields) != 0 {
		for _, fd := range st.Fields {
			name := exposeName(fd.Name)
			if st.ReadOnly {
				name = unexposeName(fd.Name)
			}
			writeStructFieldMarshaller("bbp."+name, fd.FieldType, w, settings, 1)
		}
	}
	writeLine(w, "\treturn nil")
	writeLine(w, "}")
	writeLine(w, "")
	writeLine(w, "func(bbp *%s) DecodeBebop(r io.Reader) (err error) {", exposedName)
	if st.hasLengthedType() {
		writeLine(w, "\tvar ln uint32")
	}
	if len(st.Fields) != 0 {
		for _, fd := range st.Fields {
			name := exposeName(fd.Name)
			if st.ReadOnly {
				name = unexposeName(fd.Name)
			}
			writeStructFieldUnmarshaller("&bbp."+name, fd.FieldType, w, settings, 1)
		}
	}
	writeLine(w, "\treturn nil")
	writeLine(w, "}")
	writeLine(w, "")

	// TODO: slices are not really readonly, we need to return a copy.
	if st.ReadOnly {
		for _, fd := range st.Fields {
			writeLine(w, "func (bbp %s) Get%s() %s {", exposedName, exposeName(fd.Name), fd.FieldType.GoString())
			writeLine(w, "\treturn bbp.%s", unexposeName(fd.Name))
			writeLine(w, "}")
			writeLine(w, "")
		}
	}
}

type FieldWithNumber struct {
	Field
	num uint8
}

func (msg Message) Generate(w io.Writer, settings GenerateSettings) {
	exposedName := exposeName(msg.Name)
	if msg.OpCode != 0 {
		writeLine(w, "const %sOpCode = 0x%x", exposedName, msg.OpCode)
		writeLine(w, "")
	}
	if msg.Comment != "" {
		writeLine(w, "// %s", msg.Comment)
	}
	writeLine(w, "type %s struct {", exposedName)

	fields := make([]FieldWithNumber, 0, len(msg.Fields))
	for i, fd := range msg.Fields {
		fields = append(fields, FieldWithNumber{
			Field: fd,
			num:   i,
		})
	}
	sort.Slice(fields, func(i, j int) bool {
		return fields[i].num < fields[j].num
	})
	for _, fd := range fields {
		writeFieldDefinition(fd.Field, w, settings, msg.ReadOnly, true)
	}
	writeLine(w, "}")
	writeLine(w, "")
	// writeLine(w, "func(bbp %s) EncodeBebop(w io.Writer) (err error) {", exposedName)
	// writeMessageBodyLength(fields)
	// // TODO: write total length up front
	// if len(msg.Fields) != 0 {
	// 	for _, fd := range fields {
	// 		name := exposeName(fd.Name)
	// 		if msg.ReadOnly {
	// 			name = unexposeName(fd.Name)
	// 		}
	// 		num := strconv.Itoa(int(fd.num))
	// 		name = "*bbp." + name
	// 		writeLineWithTabs(w, "%[2]sif %[3]s != nil {", 1, name)
	// 		writeLineWithTabs(w, "%[2]sw.Write([]byte{%[1]s})", 2, num)
	// 		writeMessageFieldMarshaller(name, fd.FieldType, w, settings, 2)
	// 		writeLineWithTabs(w, "%[1]s}", 1)
	// 	}
	// }
	// writeLine(w, "\treturn nil")
	// writeLine(w, "}")
	// writeLine(w, "")
	// writeLine(w, "func(bbp *%s) DecodeBebop(r io.Reader) (err error) {", exposedName)
	// if msg.hasLengthedType() {
	// 	writeLine(w, "\tvar ln uint32")
	// }
	// if len(msg.Fields) != 0 {
	// 	for _, fd := range msg.Fields {
	// 		name := exposeName(fd.Name)
	// 		if msg.ReadOnly {
	// 			name = unexposeName(fd.Name)
	// 		}
	// 		writeMessageFieldUnmarshaller("&bbp."+name, fd.FieldType, w, settings, 1)

	// 	}
	// }
	// writeLine(w, "\treturn nil")
	// writeLine(w, "}")
	// writeLine(w, "")
	// TODO: encode, decode methods
	if msg.ReadOnly {
		for _, fd := range msg.Fields {
			writeLine(w, "func (bbp %s) Get%s() *%s {", exposedName, exposeName(fd.Name), fd.FieldType.GoString())
			writeLine(w, "\treturn bbp.%s", unexposeName(fd.Name))
			writeLine(w, "}")
			writeLine(w, "")
		}
	}
}

func writeFieldDefinition(fd Field, w io.Writer, settings GenerateSettings, readOnly bool, message bool) {
	if fd.Comment != "" {
		writeLine(w, "\t// %s", fd.Comment)
	}
	if fd.Deprecated {
		writeLine(w, "\t// Deprecated: %s", fd.DeprecatedMessage)
	}

	name := exposeName(fd.Name)
	if readOnly {
		name = unexposeName(fd.Name)
	}
	typ := fd.FieldType.GoString()
	if message {
		typ = "*" + typ
	}
	writeLine(w, "\t%s %s", name, typ)
}

func writeStructFieldMarshaller(name string, typ FieldType, w io.Writer, settings GenerateSettings, depth int) {
	if typ.Array != nil {
		writeLineWithTabs(w, "%[2]sbinary.Write(w, binary.LittleEndian, uint32(len(%[1]s)))", depth, name)
		writeLineWithTabs(w, "%[2]sfor _, elem := range %[1]s {", depth, name)
		writeStructFieldMarshaller("elem", *typ.Array, w, settings, depth+1)
		writeLineWithTabs(w, "%[1]s}", depth)
	} else if typ.Map != nil {
		writeLineWithTabs(w, "%[2]sbinary.Write(w, binary.LittleEndian, uint32(len(%[1]s)))", depth, name)
		writeLineWithTabs(w, "%[2]sfor k, v := range %[1]s {", depth, name)
		writeLineWithTabs(w, settings.typeMarshallers[typ.Map.Key], depth+1, "k")
		writeStructFieldMarshaller("v", typ.Map.Value, w, settings, depth+1)
		writeLineWithTabs(w, "%[1]s}", depth)
	} else {
		writeLineWithTabs(w, settings.typeMarshallers[typ.Simple], depth, name)
	}
}

func writeStructFieldUnmarshaller(name string, typ FieldType, w io.Writer, settings GenerateSettings, depth int) {
	if typ.Array != nil {
		writeLineWithTabs(w, "%[1]sln = uint32(0)", depth)
		writeLineWithTabs(w, "%[2]sbinary.Read(r, binary.LittleEndian, &ln)", depth, name)
		writeLineWithTabs(w, "%[2]sfor i := uint32(0); i < ln; i++ {", depth, name)
		writeLineWithTabs(w, "%[2]selem := new(%[1]s)", depth+1, typ.Array.GoString())
		writeStructFieldUnmarshaller("elem", *typ.Array, w, settings, depth+1)
		writeLineWithTabs(w, "%[1]s}", depth)
	} else if typ.Map != nil {
		writeLineWithTabs(w, "%[1]sln = uint32(0)", depth)
		writeLineWithTabs(w, "%[2]sbinary.Read(r, binary.LittleEndian, &ln)", depth, name)
		writeLineWithTabs(w, "%[2]sfor i := uint32(0); i < ln; i++ {", depth, name)
		writeLineWithTabs(w, "%[2]svar k "+simpleGoString(typ.Map.Key), depth+1, name)
		writeLineWithTabs(w, settings.typeUnmarshallers[typ.Map.Key], depth+1, "k")
		writeLineWithTabs(w, "%[2]selem := new(%[1]s)", depth+1, typ.Map.Value.GoString())
		writeStructFieldUnmarshaller("elem", typ.Map.Value, w, settings, depth+1)
		writeLineWithTabs(w, "%[1]s}", depth)
	} else {
		writeLineWithTabs(w, settings.typeUnmarshallers[typ.Simple], depth, name)
	}
}

func writeMessageFieldMarshaller(name string, typ FieldType, w io.Writer, settings GenerateSettings, depth int) {
	if typ.Array != nil {
		writeLineWithTabs(w, "%[2]sbinary.Write(w, binary.LittleEndian, uint32(len(%[1]s)))", depth, name)
		writeLineWithTabs(w, "%[2]sfor _, elem := range %[1]s {", depth, name)
		writeMessageFieldMarshaller("elem", *typ.Array, w, settings, depth+1)
		writeLineWithTabs(w, "%[1]s}", depth)
	} else if typ.Map != nil {
		writeLineWithTabs(w, "%[2]sbinary.Write(w, binary.LittleEndian, uint32(len(%[1]s)))", depth, name)
		writeLineWithTabs(w, "%[2]sfor k, v := range %[1]s {", depth, name)
		writeLineWithTabs(w, settings.typeMarshallers[typ.Map.Key], depth+1, "k")
		writeMessageFieldMarshaller("v", typ.Map.Value, w, settings, depth+1)
		writeLineWithTabs(w, "%[1]s}", depth)
	} else {
		writeLineWithTabs(w, settings.typeMarshallers[typ.Simple], depth, name)
	}
}

func writeMessageFieldUnmarshaller(name string, typ FieldType, w io.Writer, settings GenerateSettings, depth int) {
	if typ.Array != nil {
		writeLineWithTabs(w, "%[1]sln = uint32(0)", depth)
		writeLineWithTabs(w, "%[2]sbinary.Read(r, binary.LittleEndian, &ln)", depth, name)
		writeLineWithTabs(w, "%[2]sfor i := uint32(0); i < ln; i++ {", depth, name)
		writeLineWithTabs(w, "%[2]selem := new(%[1]s)", depth+1, typ.Array.GoString())
		writeMessageFieldUnmarshaller("elem", *typ.Array, w, settings, depth+1)
		writeLineWithTabs(w, "%[1]s}", depth)
	} else if typ.Map != nil {
		writeLineWithTabs(w, "%[1]sln = uint32(0)", depth)
		writeLineWithTabs(w, "%[2]sbinary.Read(r, binary.LittleEndian, &ln)", depth, name)
		writeLineWithTabs(w, "%[2]sfor i := uint32(0); i < ln; i++ {", depth, name)
		writeLineWithTabs(w, "%[2]svar k "+simpleGoString(typ.Map.Key), depth+1, name)
		writeLineWithTabs(w, settings.typeUnmarshallers[typ.Map.Key], depth+1, "k")
		writeLineWithTabs(w, "%[2]selem := new(%[1]s)", depth+1, typ.Map.Value.GoString())
		writeMessageFieldUnmarshaller("elem", typ.Map.Value, w, settings, depth+1)
		writeLineWithTabs(w, "%[1]s}", depth)
	} else {
		writeLineWithTabs(w, settings.typeUnmarshallers[typ.Simple], depth, name)
	}
}

func exposeName(name string) string {
	if len(name) > 1 {
		return strings.ToUpper(string(name[0])) + name[1:]
	}
	if len(name) > 0 {
		return strings.ToUpper(string(name[0]))
	}
	return ""
}

func unexposeName(name string) string {
	if len(name) > 1 {
		return strings.ToLower(string(name[0])) + name[1:]
	}
	if len(name) > 0 {
		return strings.ToLower(string(name[0]))
	}
	return ""
}

func (f File) typeUnmarshallers() map[string]string {
	out := make(map[string]string)
	out["bool"] = "%[2]sbinary.Read(r, binary.LittleEndian, %[1]s)"
	out["byte"] = "%[2]sbinary.Read(r, binary.LittleEndian, %[1]s)"
	out["uint16"] = "%[2]sbinary.Read(r, binary.LittleEndian, %[1]s)"
	out["int16"] = "%[2]sbinary.Read(r, binary.LittleEndian, %[1]s)"
	out["uint32"] = "%[2]sbinary.Read(r, binary.LittleEndian, %[1]s)"
	out["int32"] = "%[2]sbinary.Read(r, binary.LittleEndian, %[1]s)"
	out["uint64"] = "%[2]sbinary.Read(r, binary.LittleEndian, %[1]s)"
	out["int64"] = "%[2]sbinary.Read(r, binary.LittleEndian, %[1]s)"
	// TODO: check floats
	out["float32"] = "%[2]sbinary.Read(r, binary.LittleEndian, %[1]s)"
	out["float64"] = "%[2]sbinary.Read(r, binary.LittleEndian, %[1]s)"
	out["string"] = "%[2]s%[3]s = bebop.ReadString(r)"
	// TODO: we have to do whatever .NET does for uuids
	out["guid"] = "%[2]sdata = make([]byte, 16)" +
		"%[2]sr.Read(data)" +
		"%[2]scopy(%[1]s[:], data[:16])"
	out["date"] = "%[2]stm = uint64(0)\n" +
		"%[2]sbinary.Read(r, binary.LittleEndian, (&tm))\n" +
		"%[2]stm *= 100\n" +
		"%[2]s%[1]s = time.Unix(0, tm)"
	for _, en := range f.Enums {
		out[en.Name] = "%[2]sbinary.Read(r, binary.LittleEndian, %[1]s)"
	}
	for _, st := range f.Structs {
		format := "%[2]serr = %[1]s.DecodeBebop(r)\n" +
			"%[2]sif err != nil {\n" +
			"%[2]s\treturn err\n" +
			"%[2]s}"
		out[st.Name] = format
	}
	for _, msg := range f.Messages {
		format := "%[2]serr = %[1]s.DecodeBebop(r)\n" +
			"%[2]sif err != nil {\n" +
			"%[2]s\treturn err\n" +
			"%[2]s}"
		out[msg.Name] = format
	}
	return out
}

func (f File) typeMarshallers() map[string]string {
	out := make(map[string]string)
	out["bool"] = "%[2]sbinary.Write(w, binary.LittleEndian, %[1]s)"
	out["byte"] = "%[2]sbinary.Write(w, binary.LittleEndian, %[1]s)"
	out["uint16"] = "%[2]sbinary.Write(w, binary.LittleEndian, %[1]s)"
	out["int16"] = "%[2]sbinary.Write(w, binary.LittleEndian, %[1]s)"
	out["uint32"] = "%[2]sbinary.Write(w, binary.LittleEndian, %[1]s)"
	out["int32"] = "%[2]sbinary.Write(w, binary.LittleEndian, %[1]s)"
	out["uint64"] = "%[2]sbinary.Write(w, binary.LittleEndian, %[1]s)"
	out["int64"] = "%[2]sbinary.Write(w, binary.LittleEndian, %[1]s)"
	// TODO: check floats
	out["float32"] = "%[2]sbinary.Write(w, binary.LittleEndian, %[1]s)"
	out["float64"] = "%[2]sbinary.Write(w, binary.LittleEndian, %[1]s)"
	out["string"] = "%[2]sbinary.Write(w, binary.LittleEndian, uint32(len(%[1]s)))\n" +
		"%[2]sw.Write([]byte(%[1]s))"
	// TODO: we have to do whatever .NET does for uuids
	out["guid"] = "%[2]sw.Write(%[1]s[:])"
	out["date"] = "%[2]sbinary.Write(w, binary.LittleEndian, (%[1]s.UnixNano()/100))"
	for _, en := range f.Enums {
		out[en.Name] = "%[2]sbinary.Write(w, binary.LittleEndian, uint32(%[1]s))"
	}
	for _, st := range f.Structs {
		format := "%[2]serr = %[1]s.EncodeBebop(w)\n" +
			"%[2]sif err != nil {\n" +
			"%[2]s\treturn err\n" +
			"%[2]s}"
		out[st.Name] = format
	}
	for _, msg := range f.Messages {
		format := "%[2]serr = %[1]s.EncodeBebop(w)\n" +
			"%[2]sif err != nil {\n" +
			"%[2]s\treturn err\n" +
			"%[2]s}"
		out[msg.Name] = format
	}
	return out
}

func ReadString(r io.Reader) string {
	ln := uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	data := make([]byte, ln)
	r.Read(data)
	return string(data)
}

func (f File) hasDateType() bool {
	for _, st := range f.Structs {
		for _, fd := range st.Fields {
			if fd.FieldType.hasDateType() {
				return true
			}
		}
	}
	for _, msg := range f.Messages {
		for _, fd := range msg.Fields {
			if fd.FieldType.hasDateType() {
				return true
			}
		}
	}
	return false
}

func (ft FieldType) hasDateType() bool {
	if ft.Simple == "date" {
		return true
	}
	if ft.Array != nil {
		return ft.Array.hasDateType()
	}
	if ft.Map != nil {
		if ft.Map.Key == "date" {
			return true
		}
		return ft.Map.Value.hasDateType()
	}
	return false
}

func (st Struct) hasLengthedType() bool {
	for _, fd := range st.Fields {
		if fd.FieldType.hasLengthedType() {
			return true
		}
	}
	return false
}

func (msg Message) hasLengthedType() bool {
	for _, fd := range msg.Fields {
		if fd.FieldType.hasLengthedType() {
			return true
		}
	}
	return false
}

func (ft FieldType) hasLengthedType() bool {
	if ft.Array != nil {
		return true
	}
	if ft.Map != nil {
		return true
	}
	return false
}
