// Code generated by bebopc-go; DO NOT EDIT.

package generated

import (
	"github.com/200sc/bebop"
	"github.com/200sc/bebop/iohelp"
	"io"
)

var _ bebop.Record = &fruit{}

type fruit struct {
	iD uint64
	name string
}

func (bbp fruit) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint64Bytes(buf[at:], bbp.iD)
	at += 8
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.name)))
	copy(buf[at+4:at+4+len(bbp.name)], []byte(bbp.name))
	at += 4 + len(bbp.name)
	return at
}

func (bbp *fruit) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 8 {
		return io.ErrUnexpectedEOF
	}
	bbp.iD = iohelp.ReadUint64Bytes(buf[at:])
	at += 8
	bbp.name, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		return err
	}
	at += 4 + len(bbp.name)
	return nil
}

func (bbp *fruit) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.iD = iohelp.ReadUint64Bytes(buf[at:])
	at += 8
	bbp.name = iohelp.MustReadStringBytes(buf[at:])
	at += 4 + len(bbp.name)
}

func (bbp fruit) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint64(w, bbp.iD)
	iohelp.WriteUint32(w, uint32(len(bbp.name)))
	w.Write([]byte(bbp.name))
	return w.Err
}

func (bbp *fruit) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.iD = iohelp.ReadUint64(r)
	bbp.name = iohelp.ReadString(r)
	return r.Err
}

func (bbp fruit) Size() int {
	bodyLen := 0
	bodyLen += 8
	bodyLen += 4 + len(bbp.name)
	return bodyLen
}

func (bbp fruit) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makefruit(r *iohelp.ErrorReader) (fruit, error) {
	v := fruit{}
	err := v.DecodeBebop(r)
	return v, err
}

func makefruitFromBytes(buf []byte) (fruit, error) {
	v := fruit{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakefruitFromBytes(buf []byte) fruit {
	v := fruit{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &basket{}

type basket struct {
	apples fruit
	oranges fruit
	mangos fruit
}

func (bbp basket) MarshalBebopTo(buf []byte) int {
	at := 0
	(bbp.apples).MarshalBebopTo(buf[at:])
	{
		tmp := (bbp.apples)
		at += tmp.Size()
	}
	
	(bbp.oranges).MarshalBebopTo(buf[at:])
	{
		tmp := (bbp.oranges)
		at += tmp.Size()
	}
	
	(bbp.mangos).MarshalBebopTo(buf[at:])
	{
		tmp := (bbp.mangos)
		at += tmp.Size()
	}
	
	return at
}

func (bbp *basket) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	bbp.apples, err = makefruitFromBytes(buf[at:])
	if err != nil {
		return err
	}
	{
		tmp := (bbp.apples)
		at += tmp.Size()
	}
	
	bbp.oranges, err = makefruitFromBytes(buf[at:])
	if err != nil {
		return err
	}
	{
		tmp := (bbp.oranges)
		at += tmp.Size()
	}
	
	bbp.mangos, err = makefruitFromBytes(buf[at:])
	if err != nil {
		return err
	}
	{
		tmp := (bbp.mangos)
		at += tmp.Size()
	}
	
	return nil
}

func (bbp *basket) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.apples = mustMakefruitFromBytes(buf[at:])
	{
		tmp := (bbp.apples)
		at += tmp.Size()
	}
	
	bbp.oranges = mustMakefruitFromBytes(buf[at:])
	{
		tmp := (bbp.oranges)
		at += tmp.Size()
	}
	
	bbp.mangos = mustMakefruitFromBytes(buf[at:])
	{
		tmp := (bbp.mangos)
		at += tmp.Size()
	}
	
}

func (bbp basket) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	err = (bbp.apples).EncodeBebop(w)
	if err != nil {
		return err
	}
	err = (bbp.oranges).EncodeBebop(w)
	if err != nil {
		return err
	}
	err = (bbp.mangos).EncodeBebop(w)
	if err != nil {
		return err
	}
	return w.Err
}

func (bbp *basket) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	(bbp.apples), err = makefruit(r)
	if err != nil {
		return err
	}
	(bbp.oranges), err = makefruit(r)
	if err != nil {
		return err
	}
	(bbp.mangos), err = makefruit(r)
	if err != nil {
		return err
	}
	return r.Err
}

func (bbp basket) Size() int {
	bodyLen := 0
	{
		tmp := (bbp.apples)
		bodyLen += tmp.Size()
	}
	
	{
		tmp := (bbp.oranges)
		bodyLen += tmp.Size()
	}
	
	{
		tmp := (bbp.mangos)
		bodyLen += tmp.Size()
	}
	
	return bodyLen
}

func (bbp basket) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makebasket(r *iohelp.ErrorReader) (basket, error) {
	v := basket{}
	err := v.DecodeBebop(r)
	return v, err
}

func makebasketFromBytes(buf []byte) (basket, error) {
	v := basket{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakebasketFromBytes(buf []byte) basket {
	v := basket{}
	v.MustUnmarshalBebop(buf)
	return v
}

