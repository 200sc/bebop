// Code generated by bebopc-go; DO NOT EDIT.

package generated

import (
	"github.com/200sc/bebop"
	"github.com/200sc/bebop/iohelp"
	"io"
)

type videoCodec uint32

const (
	videoCodec_H264 videoCodec = 0
	videoCodec_H265 videoCodec = 1
)

var _ bebop.Record = &int32s{}

type int32s struct {
	a []int32
}

func (bbp int32s) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.a)))
	at += 4
	for _, v1 := range bbp.a {
		iohelp.WriteInt32Bytes(buf[at:], v1)
		at += 4
	}
	return at
}

func (bbp *int32s) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.a = make([]int32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.a)*4 {
		return io.ErrUnexpectedEOF
	}
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadInt32Bytes(buf[at:])
		at += 4
	}
	return nil
}

func (bbp *int32s) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.a = make([]int32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadInt32Bytes(buf[at:])
		at += 4
	}
}

func (bbp int32s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.a)))
	for _, elem := range bbp.a {
		iohelp.WriteInt32(w, elem)
	}
	return w.Err
}

func (bbp *int32s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.a = make([]int32, iohelp.ReadUint32(r))
	for i1 := range bbp.a {
		(bbp.a[i1]) = iohelp.ReadInt32(r)
	}
	return r.Err
}

func (bbp int32s) Size() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.a) * 4
	return bodyLen
}

func (bbp int32s) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makeint32s(r iohelp.ErrorReader) (int32s, error) {
	v := int32s{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeint32sFromBytes(buf []byte) (int32s, error) {
	v := int32s{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeint32sFromBytes(buf []byte) int32s {
	v := int32s{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &uint32s{}

type uint32s struct {
	a []uint32
}

func (bbp uint32s) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.a)))
	at += 4
	for _, v1 := range bbp.a {
		iohelp.WriteUint32Bytes(buf[at:], v1)
		at += 4
	}
	return at
}

func (bbp *uint32s) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.a = make([]uint32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.a)*4 {
		return io.ErrUnexpectedEOF
	}
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadUint32Bytes(buf[at:])
		at += 4
	}
	return nil
}

func (bbp *uint32s) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.a = make([]uint32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadUint32Bytes(buf[at:])
		at += 4
	}
}

func (bbp uint32s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.a)))
	for _, elem := range bbp.a {
		iohelp.WriteUint32(w, elem)
	}
	return w.Err
}

func (bbp *uint32s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.a = make([]uint32, iohelp.ReadUint32(r))
	for i1 := range bbp.a {
		(bbp.a[i1]) = iohelp.ReadUint32(r)
	}
	return r.Err
}

func (bbp uint32s) Size() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.a) * 4
	return bodyLen
}

func (bbp uint32s) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makeuint32s(r iohelp.ErrorReader) (uint32s, error) {
	v := uint32s{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeuint32sFromBytes(buf []byte) (uint32s, error) {
	v := uint32s{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeuint32sFromBytes(buf []byte) uint32s {
	v := uint32s{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &float32s{}

type float32s struct {
	a []float32
}

func (bbp float32s) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.a)))
	at += 4
	for _, v1 := range bbp.a {
		iohelp.WriteFloat32Bytes(buf[at:], v1)
		at += 4
	}
	return at
}

func (bbp *float32s) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.a = make([]float32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.a)*4 {
		return io.ErrUnexpectedEOF
	}
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadFloat32Bytes(buf[at:])
		at += 4
	}
	return nil
}

func (bbp *float32s) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.a = make([]float32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadFloat32Bytes(buf[at:])
		at += 4
	}
}

func (bbp float32s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.a)))
	for _, elem := range bbp.a {
		iohelp.WriteFloat32(w, elem)
	}
	return w.Err
}

func (bbp *float32s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.a = make([]float32, iohelp.ReadUint32(r))
	for i1 := range bbp.a {
		(bbp.a[i1]) = iohelp.ReadFloat32(r)
	}
	return r.Err
}

func (bbp float32s) Size() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.a) * 4
	return bodyLen
}

func (bbp float32s) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makefloat32s(r iohelp.ErrorReader) (float32s, error) {
	v := float32s{}
	err := v.DecodeBebop(r)
	return v, err
}

func makefloat32sFromBytes(buf []byte) (float32s, error) {
	v := float32s{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakefloat32sFromBytes(buf []byte) float32s {
	v := float32s{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &int64s{}

type int64s struct {
	a []int64
}

func (bbp int64s) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.a)))
	at += 4
	for _, v1 := range bbp.a {
		iohelp.WriteInt64Bytes(buf[at:], v1)
		at += 8
	}
	return at
}

func (bbp *int64s) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.a = make([]int64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.a)*8 {
		return io.ErrUnexpectedEOF
	}
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadInt64Bytes(buf[at:])
		at += 8
	}
	return nil
}

func (bbp *int64s) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.a = make([]int64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadInt64Bytes(buf[at:])
		at += 8
	}
}

func (bbp int64s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.a)))
	for _, elem := range bbp.a {
		iohelp.WriteInt64(w, elem)
	}
	return w.Err
}

func (bbp *int64s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.a = make([]int64, iohelp.ReadUint32(r))
	for i1 := range bbp.a {
		(bbp.a[i1]) = iohelp.ReadInt64(r)
	}
	return r.Err
}

func (bbp int64s) Size() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.a) * 8
	return bodyLen
}

func (bbp int64s) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makeint64s(r iohelp.ErrorReader) (int64s, error) {
	v := int64s{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeint64sFromBytes(buf []byte) (int64s, error) {
	v := int64s{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeint64sFromBytes(buf []byte) int64s {
	v := int64s{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &uint64s{}

type uint64s struct {
	a []uint64
}

func (bbp uint64s) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.a)))
	at += 4
	for _, v1 := range bbp.a {
		iohelp.WriteUint64Bytes(buf[at:], v1)
		at += 8
	}
	return at
}

func (bbp *uint64s) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.a = make([]uint64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.a)*8 {
		return io.ErrUnexpectedEOF
	}
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadUint64Bytes(buf[at:])
		at += 8
	}
	return nil
}

func (bbp *uint64s) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.a = make([]uint64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadUint64Bytes(buf[at:])
		at += 8
	}
}

func (bbp uint64s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.a)))
	for _, elem := range bbp.a {
		iohelp.WriteUint64(w, elem)
	}
	return w.Err
}

func (bbp *uint64s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.a = make([]uint64, iohelp.ReadUint32(r))
	for i1 := range bbp.a {
		(bbp.a[i1]) = iohelp.ReadUint64(r)
	}
	return r.Err
}

func (bbp uint64s) Size() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.a) * 8
	return bodyLen
}

func (bbp uint64s) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makeuint64s(r iohelp.ErrorReader) (uint64s, error) {
	v := uint64s{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeuint64sFromBytes(buf []byte) (uint64s, error) {
	v := uint64s{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeuint64sFromBytes(buf []byte) uint64s {
	v := uint64s{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &float64s{}

type float64s struct {
	a []float64
}

func (bbp float64s) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.a)))
	at += 4
	for _, v1 := range bbp.a {
		iohelp.WriteFloat64Bytes(buf[at:], v1)
		at += 8
	}
	return at
}

func (bbp *float64s) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.a = make([]float64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.a)*8 {
		return io.ErrUnexpectedEOF
	}
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadFloat64Bytes(buf[at:])
		at += 8
	}
	return nil
}

func (bbp *float64s) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.a = make([]float64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.a {
		(bbp.a)[i1] = iohelp.ReadFloat64Bytes(buf[at:])
		at += 8
	}
}

func (bbp float64s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.a)))
	for _, elem := range bbp.a {
		iohelp.WriteFloat64(w, elem)
	}
	return w.Err
}

func (bbp *float64s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.a = make([]float64, iohelp.ReadUint32(r))
	for i1 := range bbp.a {
		(bbp.a[i1]) = iohelp.ReadFloat64(r)
	}
	return r.Err
}

func (bbp float64s) Size() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.a) * 8
	return bodyLen
}

func (bbp float64s) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makefloat64s(r iohelp.ErrorReader) (float64s, error) {
	v := float64s{}
	err := v.DecodeBebop(r)
	return v, err
}

func makefloat64sFromBytes(buf []byte) (float64s, error) {
	v := float64s{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakefloat64sFromBytes(buf []byte) float64s {
	v := float64s{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &videoData{}

type videoData struct {
	time float64
	width uint32
	height uint32
	fragment []byte
}

func (bbp videoData) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteFloat64Bytes(buf[at:], bbp.time)
	at += 8
	iohelp.WriteUint32Bytes(buf[at:], bbp.width)
	at += 4
	iohelp.WriteUint32Bytes(buf[at:], bbp.height)
	at += 4
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.fragment)))
	at += 4
	copy(buf[at:at+len(bbp.fragment)], bbp.fragment)
	at += len(bbp.fragment)
	return at
}

func (bbp *videoData) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 8 {
		return io.ErrUnexpectedEOF
	}
	bbp.time = iohelp.ReadFloat64Bytes(buf[at:])
	at += 8
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.width = iohelp.ReadUint32Bytes(buf[at:])
	at += 4
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.height = iohelp.ReadUint32Bytes(buf[at:])
	at += 4
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.fragment = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.fragment)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.fragment, buf[at:at+len(bbp.fragment)])
	at += len(bbp.fragment)
	return nil
}

func (bbp *videoData) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.time = iohelp.ReadFloat64Bytes(buf[at:])
	at += 8
	bbp.width = iohelp.ReadUint32Bytes(buf[at:])
	at += 4
	bbp.height = iohelp.ReadUint32Bytes(buf[at:])
	at += 4
	bbp.fragment = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	copy(bbp.fragment, buf[at:at+len(bbp.fragment)])
	at += len(bbp.fragment)
}

func (bbp videoData) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteFloat64(w, bbp.time)
	iohelp.WriteUint32(w, bbp.width)
	iohelp.WriteUint32(w, bbp.height)
	iohelp.WriteUint32(w, uint32(len(bbp.fragment)))
	for _, elem := range bbp.fragment {
		iohelp.WriteByte(w, elem)
	}
	return w.Err
}

func (bbp *videoData) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.time = iohelp.ReadFloat64(r)
	bbp.width = iohelp.ReadUint32(r)
	bbp.height = iohelp.ReadUint32(r)
	bbp.fragment = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.fragment {
		(bbp.fragment[i1]) = iohelp.ReadByte(r)
	}
	return r.Err
}

func (bbp videoData) Size() int {
	bodyLen := 0
	bodyLen += 8
	bodyLen += 4
	bodyLen += 4
	bodyLen += 4
	bodyLen += len(bbp.fragment) * 1
	return bodyLen
}

func (bbp videoData) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makevideoData(r iohelp.ErrorReader) (videoData, error) {
	v := videoData{}
	err := v.DecodeBebop(r)
	return v, err
}

func makevideoDataFromBytes(buf []byte) (videoData, error) {
	v := videoData{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakevideoDataFromBytes(buf []byte) videoData {
	v := videoData{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &mediaMessage{}

type mediaMessage struct {
	codec *videoCodec
	data *videoData
}

func (bbp mediaMessage) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(bbp.Size()-4))
	at += 4
	if bbp.codec != nil {
		buf[at] = 1
		at++
		iohelp.WriteUint32Bytes(buf[at:], uint32(*bbp.codec))
		at += 4
	}
	if bbp.data != nil {
		buf[at] = 2
		at++
		(*bbp.data).MarshalBebopTo(buf[at:])
		tmp8193 := (*bbp.data); at += tmp8193.Size()
	}
	return at
}

func (bbp *mediaMessage) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.codec = new(videoCodec)
			(*bbp.codec) = videoCodec(iohelp.ReadUint32Bytes(buf[at:]))
			at += 4
		case 2:
			at += 1
			bbp.data = new(videoData)
			(*bbp.data), err = makevideoDataFromBytes(buf[at:])
			if err != nil {
				return err
			}
			tmp8204 := ((*bbp.data)); at += tmp8204.Size()
		default:
			return nil
		}
	}
}

func (bbp *mediaMessage) MustUnmarshalBebop(buf []byte) {
	at := 0
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.codec = new(videoCodec)
			(*bbp.codec) = videoCodec(iohelp.ReadUint32Bytes(buf[at:]))
			at += 4
		case 2:
			at += 1
			bbp.data = new(videoData)
			(*bbp.data) = mustMakevideoDataFromBytes(buf[at:])
			tmp8706 := ((*bbp.data)); at += tmp8706.Size()
		default:
			return
		}
	}
}

func (bbp mediaMessage) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(bbp.Size()-4))
	if bbp.codec != nil {
		w.Write([]byte{1})
		iohelp.WriteUint32(w, uint32(*bbp.codec))
	}
	if bbp.data != nil {
		w.Write([]byte{2})
		err = (*bbp.data).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *mediaMessage) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bodyLen := iohelp.ReadUint32(r)
	r.Reader = &io.LimitedReader{R:r.Reader, N:int64(bodyLen)}
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.codec = new(videoCodec)
			*bbp.codec = videoCodec(iohelp.ReadUint32(r))
		case 2:
			bbp.data = new(videoData)
			(*bbp.data), err = makevideoData(r)
			if err != nil {
				return err
			}
		default:
			io.ReadAll(r)
			return r.Err
		}
	}
}

func (bbp mediaMessage) Size() int {
	bodyLen := 5
	if bbp.codec != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.data != nil {
		bodyLen += 1
		tmp8723 := (*bbp.data); bodyLen += tmp8723.Size()
	}
	return bodyLen
}

func (bbp mediaMessage) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makemediaMessage(r iohelp.ErrorReader) (mediaMessage, error) {
	v := mediaMessage{}
	err := v.DecodeBebop(r)
	return v, err
}

func makemediaMessageFromBytes(buf []byte) (mediaMessage, error) {
	v := mediaMessage{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakemediaMessageFromBytes(buf []byte) mediaMessage {
	v := mediaMessage{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &skipTestOld{}

// Should be able to decode a "SkipTestNewContainer" as a "SkipTestOldContainer".
type skipTestOld struct {
	x *int32
	y *int32
}

func (bbp skipTestOld) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(bbp.Size()-4))
	at += 4
	if bbp.x != nil {
		buf[at] = 1
		at++
		iohelp.WriteInt32Bytes(buf[at:], *bbp.x)
		at += 4
	}
	if bbp.y != nil {
		buf[at] = 2
		at++
		iohelp.WriteInt32Bytes(buf[at:], *bbp.y)
		at += 4
	}
	return at
}

func (bbp *skipTestOld) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.x = new(int32)
			if len(buf[at:]) < 4 {
				return io.ErrUnexpectedEOF
			}
			(*bbp.x) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		case 2:
			at += 1
			bbp.y = new(int32)
			if len(buf[at:]) < 4 {
				return io.ErrUnexpectedEOF
			}
			(*bbp.y) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		default:
			return nil
		}
	}
}

func (bbp *skipTestOld) MustUnmarshalBebop(buf []byte) {
	at := 0
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.x = new(int32)
			(*bbp.x) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		case 2:
			at += 1
			bbp.y = new(int32)
			(*bbp.y) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		default:
			return
		}
	}
}

func (bbp skipTestOld) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(bbp.Size()-4))
	if bbp.x != nil {
		w.Write([]byte{1})
		iohelp.WriteInt32(w, *bbp.x)
	}
	if bbp.y != nil {
		w.Write([]byte{2})
		iohelp.WriteInt32(w, *bbp.y)
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *skipTestOld) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bodyLen := iohelp.ReadUint32(r)
	r.Reader = &io.LimitedReader{R:r.Reader, N:int64(bodyLen)}
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.x = new(int32)
			*bbp.x = iohelp.ReadInt32(r)
		case 2:
			bbp.y = new(int32)
			*bbp.y = iohelp.ReadInt32(r)
		default:
			io.ReadAll(r)
			return r.Err
		}
	}
}

func (bbp skipTestOld) Size() int {
	bodyLen := 5
	if bbp.x != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.y != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

func (bbp skipTestOld) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makeskipTestOld(r iohelp.ErrorReader) (skipTestOld, error) {
	v := skipTestOld{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeskipTestOldFromBytes(buf []byte) (skipTestOld, error) {
	v := skipTestOld{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeskipTestOldFromBytes(buf []byte) skipTestOld {
	v := skipTestOld{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &skipTestNew{}

type skipTestNew struct {
	x *int32
	y *int32
	z *int32
}

func (bbp skipTestNew) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(bbp.Size()-4))
	at += 4
	if bbp.x != nil {
		buf[at] = 1
		at++
		iohelp.WriteInt32Bytes(buf[at:], *bbp.x)
		at += 4
	}
	if bbp.y != nil {
		buf[at] = 2
		at++
		iohelp.WriteInt32Bytes(buf[at:], *bbp.y)
		at += 4
	}
	if bbp.z != nil {
		buf[at] = 3
		at++
		iohelp.WriteInt32Bytes(buf[at:], *bbp.z)
		at += 4
	}
	return at
}

func (bbp *skipTestNew) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.x = new(int32)
			if len(buf[at:]) < 4 {
				return io.ErrUnexpectedEOF
			}
			(*bbp.x) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		case 2:
			at += 1
			bbp.y = new(int32)
			if len(buf[at:]) < 4 {
				return io.ErrUnexpectedEOF
			}
			(*bbp.y) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		case 3:
			at += 1
			bbp.z = new(int32)
			if len(buf[at:]) < 4 {
				return io.ErrUnexpectedEOF
			}
			(*bbp.z) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		default:
			return nil
		}
	}
}

func (bbp *skipTestNew) MustUnmarshalBebop(buf []byte) {
	at := 0
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.x = new(int32)
			(*bbp.x) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		case 2:
			at += 1
			bbp.y = new(int32)
			(*bbp.y) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		case 3:
			at += 1
			bbp.z = new(int32)
			(*bbp.z) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		default:
			return
		}
	}
}

func (bbp skipTestNew) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(bbp.Size()-4))
	if bbp.x != nil {
		w.Write([]byte{1})
		iohelp.WriteInt32(w, *bbp.x)
	}
	if bbp.y != nil {
		w.Write([]byte{2})
		iohelp.WriteInt32(w, *bbp.y)
	}
	if bbp.z != nil {
		w.Write([]byte{3})
		iohelp.WriteInt32(w, *bbp.z)
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *skipTestNew) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bodyLen := iohelp.ReadUint32(r)
	r.Reader = &io.LimitedReader{R:r.Reader, N:int64(bodyLen)}
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.x = new(int32)
			*bbp.x = iohelp.ReadInt32(r)
		case 2:
			bbp.y = new(int32)
			*bbp.y = iohelp.ReadInt32(r)
		case 3:
			bbp.z = new(int32)
			*bbp.z = iohelp.ReadInt32(r)
		default:
			io.ReadAll(r)
			return r.Err
		}
	}
}

func (bbp skipTestNew) Size() int {
	bodyLen := 5
	if bbp.x != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.y != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.z != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

func (bbp skipTestNew) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makeskipTestNew(r iohelp.ErrorReader) (skipTestNew, error) {
	v := skipTestNew{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeskipTestNewFromBytes(buf []byte) (skipTestNew, error) {
	v := skipTestNew{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeskipTestNewFromBytes(buf []byte) skipTestNew {
	v := skipTestNew{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &skipTestOldContainer{}

type skipTestOldContainer struct {
	s *skipTestOld
	after *int32
}

func (bbp skipTestOldContainer) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(bbp.Size()-4))
	at += 4
	if bbp.s != nil {
		buf[at] = 1
		at++
		(*bbp.s).MarshalBebopTo(buf[at:])
		tmp8823 := (*bbp.s); at += tmp8823.Size()
	}
	if bbp.after != nil {
		buf[at] = 2
		at++
		iohelp.WriteInt32Bytes(buf[at:], *bbp.after)
		at += 4
	}
	return at
}

func (bbp *skipTestOldContainer) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.s = new(skipTestOld)
			(*bbp.s), err = makeskipTestOldFromBytes(buf[at:])
			if err != nil {
				return err
			}
			tmp8830 := ((*bbp.s)); at += tmp8830.Size()
		case 2:
			at += 1
			bbp.after = new(int32)
			if len(buf[at:]) < 4 {
				return io.ErrUnexpectedEOF
			}
			(*bbp.after) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		default:
			return nil
		}
	}
}

func (bbp *skipTestOldContainer) MustUnmarshalBebop(buf []byte) {
	at := 0
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.s = new(skipTestOld)
			(*bbp.s) = mustMakeskipTestOldFromBytes(buf[at:])
			tmp8835 := ((*bbp.s)); at += tmp8835.Size()
		case 2:
			at += 1
			bbp.after = new(int32)
			(*bbp.after) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		default:
			return
		}
	}
}

func (bbp skipTestOldContainer) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(bbp.Size()-4))
	if bbp.s != nil {
		w.Write([]byte{1})
		err = (*bbp.s).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	if bbp.after != nil {
		w.Write([]byte{2})
		iohelp.WriteInt32(w, *bbp.after)
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *skipTestOldContainer) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bodyLen := iohelp.ReadUint32(r)
	r.Reader = &io.LimitedReader{R:r.Reader, N:int64(bodyLen)}
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.s = new(skipTestOld)
			(*bbp.s), err = makeskipTestOld(r)
			if err != nil {
				return err
			}
		case 2:
			bbp.after = new(int32)
			*bbp.after = iohelp.ReadInt32(r)
		default:
			io.ReadAll(r)
			return r.Err
		}
	}
}

func (bbp skipTestOldContainer) Size() int {
	bodyLen := 5
	if bbp.s != nil {
		bodyLen += 1
		tmp8849 := (*bbp.s); bodyLen += tmp8849.Size()
	}
	if bbp.after != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

func (bbp skipTestOldContainer) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makeskipTestOldContainer(r iohelp.ErrorReader) (skipTestOldContainer, error) {
	v := skipTestOldContainer{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeskipTestOldContainerFromBytes(buf []byte) (skipTestOldContainer, error) {
	v := skipTestOldContainer{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeskipTestOldContainerFromBytes(buf []byte) skipTestOldContainer {
	v := skipTestOldContainer{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &skipTestNewContainer{}

type skipTestNewContainer struct {
	s *skipTestNew
	after *int32
}

func (bbp skipTestNewContainer) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(bbp.Size()-4))
	at += 4
	if bbp.s != nil {
		buf[at] = 1
		at++
		(*bbp.s).MarshalBebopTo(buf[at:])
		tmp8858 := (*bbp.s); at += tmp8858.Size()
	}
	if bbp.after != nil {
		buf[at] = 2
		at++
		iohelp.WriteInt32Bytes(buf[at:], *bbp.after)
		at += 4
	}
	return at
}

func (bbp *skipTestNewContainer) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.s = new(skipTestNew)
			(*bbp.s), err = makeskipTestNewFromBytes(buf[at:])
			if err != nil {
				return err
			}
			tmp8865 := ((*bbp.s)); at += tmp8865.Size()
		case 2:
			at += 1
			bbp.after = new(int32)
			if len(buf[at:]) < 4 {
				return io.ErrUnexpectedEOF
			}
			(*bbp.after) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		default:
			return nil
		}
	}
}

func (bbp *skipTestNewContainer) MustUnmarshalBebop(buf []byte) {
	at := 0
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.s = new(skipTestNew)
			(*bbp.s) = mustMakeskipTestNewFromBytes(buf[at:])
			tmp8870 := ((*bbp.s)); at += tmp8870.Size()
		case 2:
			at += 1
			bbp.after = new(int32)
			(*bbp.after) = iohelp.ReadInt32Bytes(buf[at:])
			at += 4
		default:
			return
		}
	}
}

func (bbp skipTestNewContainer) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(bbp.Size()-4))
	if bbp.s != nil {
		w.Write([]byte{1})
		err = (*bbp.s).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	if bbp.after != nil {
		w.Write([]byte{2})
		iohelp.WriteInt32(w, *bbp.after)
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *skipTestNewContainer) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bodyLen := iohelp.ReadUint32(r)
	r.Reader = &io.LimitedReader{R:r.Reader, N:int64(bodyLen)}
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.s = new(skipTestNew)
			(*bbp.s), err = makeskipTestNew(r)
			if err != nil {
				return err
			}
		case 2:
			bbp.after = new(int32)
			*bbp.after = iohelp.ReadInt32(r)
		default:
			io.ReadAll(r)
			return r.Err
		}
	}
}

func (bbp skipTestNewContainer) Size() int {
	bodyLen := 5
	if bbp.s != nil {
		bodyLen += 1
		tmp8884 := (*bbp.s); bodyLen += tmp8884.Size()
	}
	if bbp.after != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

func (bbp skipTestNewContainer) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makeskipTestNewContainer(r iohelp.ErrorReader) (skipTestNewContainer, error) {
	v := skipTestNewContainer{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeskipTestNewContainerFromBytes(buf []byte) (skipTestNewContainer, error) {
	v := skipTestNewContainer{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeskipTestNewContainerFromBytes(buf []byte) skipTestNewContainer {
	v := skipTestNewContainer{}
	v.MustUnmarshalBebop(buf)
	return v
}

