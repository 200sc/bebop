// Code generated by bebopc-go; DO NOT EDIT.

package generated

import (
	"io"
	"github.com/200sc/bebop"
	"github.com/200sc/bebop/iohelp"
)

var _ bebop.Record = &BasicArrays{}

type BasicArrays struct {
	A_bool []bool
	A_byte []byte
	A_int16 []int16
	A_uint16 []uint16
	A_int32 []int32
	A_uint32 []uint32
	A_int64 []int64
	A_uint64 []uint64
	A_float32 []float32
	A_float64 []float64
	A_string []string
	A_guid [][16]byte
}

func (bbp BasicArrays) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func (bbp BasicArrays) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_bool)))
	at += 4
	for _, v1 := range bbp.A_bool {
		iohelp.WriteBoolBytes(buf[at:], v1)
		at += 1
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_byte)))
	at += 4
	copy(buf[at:at+len(bbp.A_byte)], bbp.A_byte)
	at += len(bbp.A_byte)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_int16)))
	at += 4
	for _, v1 := range bbp.A_int16 {
		iohelp.WriteInt16Bytes(buf[at:], v1)
		at += 2
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_uint16)))
	at += 4
	for _, v1 := range bbp.A_uint16 {
		iohelp.WriteUint16Bytes(buf[at:], v1)
		at += 2
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_int32)))
	at += 4
	for _, v1 := range bbp.A_int32 {
		iohelp.WriteInt32Bytes(buf[at:], v1)
		at += 4
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_uint32)))
	at += 4
	for _, v1 := range bbp.A_uint32 {
		iohelp.WriteUint32Bytes(buf[at:], v1)
		at += 4
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_int64)))
	at += 4
	for _, v1 := range bbp.A_int64 {
		iohelp.WriteInt64Bytes(buf[at:], v1)
		at += 8
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_uint64)))
	at += 4
	for _, v1 := range bbp.A_uint64 {
		iohelp.WriteUint64Bytes(buf[at:], v1)
		at += 8
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_float32)))
	at += 4
	for _, v1 := range bbp.A_float32 {
		iohelp.WriteFloat32Bytes(buf[at:], v1)
		at += 4
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_float64)))
	at += 4
	for _, v1 := range bbp.A_float64 {
		iohelp.WriteFloat64Bytes(buf[at:], v1)
		at += 8
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_string)))
	at += 4
	for _, v1 := range bbp.A_string {
		iohelp.WriteUint32Bytes(buf[at:], uint32(len(v1)))
		copy(buf[at+4:at+4+len(v1)], []byte(v1))
		at += 4 + len(v1)
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A_guid)))
	at += 4
	for _, v1 := range bbp.A_guid {
		iohelp.WriteGUIDBytes(buf[at:], v1)
		at += 16
	}
	return at
}

func (bbp *BasicArrays) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_bool = make([]bool, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A_bool)*1 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.A_bool {
		(bbp.A_bool)[i1] = iohelp.ReadBoolBytes(buf[at:])
		at += 1
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_byte = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A_byte)*1 {
		 return iohelp.ErrTooShort
	}
	copy(bbp.A_byte, buf[at:at+len(bbp.A_byte)])
	at += len(bbp.A_byte)
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_int16 = make([]int16, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A_int16)*2 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.A_int16 {
		(bbp.A_int16)[i1] = iohelp.ReadInt16Bytes(buf[at:])
		at += 2
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_uint16 = make([]uint16, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A_uint16)*2 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.A_uint16 {
		(bbp.A_uint16)[i1] = iohelp.ReadUint16Bytes(buf[at:])
		at += 2
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_int32 = make([]int32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A_int32)*4 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.A_int32 {
		(bbp.A_int32)[i1] = iohelp.ReadInt32Bytes(buf[at:])
		at += 4
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_uint32 = make([]uint32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A_uint32)*4 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.A_uint32 {
		(bbp.A_uint32)[i1] = iohelp.ReadUint32Bytes(buf[at:])
		at += 4
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_int64 = make([]int64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A_int64)*8 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.A_int64 {
		(bbp.A_int64)[i1] = iohelp.ReadInt64Bytes(buf[at:])
		at += 8
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_uint64 = make([]uint64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A_uint64)*8 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.A_uint64 {
		(bbp.A_uint64)[i1] = iohelp.ReadUint64Bytes(buf[at:])
		at += 8
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_float32 = make([]float32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A_float32)*4 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.A_float32 {
		(bbp.A_float32)[i1] = iohelp.ReadFloat32Bytes(buf[at:])
		at += 4
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_float64 = make([]float64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A_float64)*8 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.A_float64 {
		(bbp.A_float64)[i1] = iohelp.ReadFloat64Bytes(buf[at:])
		at += 8
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_string = make([]string, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_string {
		(bbp.A_string)[i1], err = iohelp.ReadStringBytes(buf[at:])
		if err != nil{
			return err
		}
		at += 4 + len((bbp.A_string)[i1])
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A_guid = make([][16]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A_guid)*16 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.A_guid {
		(bbp.A_guid)[i1] = iohelp.ReadGUIDBytes(buf[at:])
		at += 16
	}
	return nil
}

func (bbp *BasicArrays) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.A_bool = make([]bool, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_bool {
		(bbp.A_bool)[i1] = iohelp.ReadBoolBytes(buf[at:])
		at += 1
	}
	bbp.A_byte = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	copy(bbp.A_byte, buf[at:at+len(bbp.A_byte)])
	at += len(bbp.A_byte)
	bbp.A_int16 = make([]int16, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_int16 {
		(bbp.A_int16)[i1] = iohelp.ReadInt16Bytes(buf[at:])
		at += 2
	}
	bbp.A_uint16 = make([]uint16, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_uint16 {
		(bbp.A_uint16)[i1] = iohelp.ReadUint16Bytes(buf[at:])
		at += 2
	}
	bbp.A_int32 = make([]int32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_int32 {
		(bbp.A_int32)[i1] = iohelp.ReadInt32Bytes(buf[at:])
		at += 4
	}
	bbp.A_uint32 = make([]uint32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_uint32 {
		(bbp.A_uint32)[i1] = iohelp.ReadUint32Bytes(buf[at:])
		at += 4
	}
	bbp.A_int64 = make([]int64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_int64 {
		(bbp.A_int64)[i1] = iohelp.ReadInt64Bytes(buf[at:])
		at += 8
	}
	bbp.A_uint64 = make([]uint64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_uint64 {
		(bbp.A_uint64)[i1] = iohelp.ReadUint64Bytes(buf[at:])
		at += 8
	}
	bbp.A_float32 = make([]float32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_float32 {
		(bbp.A_float32)[i1] = iohelp.ReadFloat32Bytes(buf[at:])
		at += 4
	}
	bbp.A_float64 = make([]float64, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_float64 {
		(bbp.A_float64)[i1] = iohelp.ReadFloat64Bytes(buf[at:])
		at += 8
	}
	bbp.A_string = make([]string, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_string {
		(bbp.A_string)[i1] =  iohelp.MustReadStringBytes(buf[at:])
		at += 4 + len((bbp.A_string)[i1])
	}
	bbp.A_guid = make([][16]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A_guid {
		(bbp.A_guid)[i1] = iohelp.ReadGUIDBytes(buf[at:])
		at += 16
	}
}

func (bbp BasicArrays) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.A_bool)))
	for _, elem := range bbp.A_bool {
		iohelp.WriteBool(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.A_byte)))
	for _, elem := range bbp.A_byte {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.A_int16)))
	for _, elem := range bbp.A_int16 {
		iohelp.WriteInt16(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.A_uint16)))
	for _, elem := range bbp.A_uint16 {
		iohelp.WriteUint16(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.A_int32)))
	for _, elem := range bbp.A_int32 {
		iohelp.WriteInt32(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.A_uint32)))
	for _, elem := range bbp.A_uint32 {
		iohelp.WriteUint32(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.A_int64)))
	for _, elem := range bbp.A_int64 {
		iohelp.WriteInt64(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.A_uint64)))
	for _, elem := range bbp.A_uint64 {
		iohelp.WriteUint64(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.A_float32)))
	for _, elem := range bbp.A_float32 {
		iohelp.WriteFloat32(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.A_float64)))
	for _, elem := range bbp.A_float64 {
		iohelp.WriteFloat64(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.A_string)))
	for _, elem := range bbp.A_string {
		iohelp.WriteUint32(w, uint32(len(elem)))
		w.Write([]byte(elem))
	}
	iohelp.WriteUint32(w, uint32(len(bbp.A_guid)))
	for _, elem := range bbp.A_guid {
		iohelp.WriteGUID(w, elem)
	}
	return w.Err
}

func (bbp *BasicArrays) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.A_bool = make([]bool, iohelp.ReadUint32(r))
	for i1 := range bbp.A_bool {
		(bbp.A_bool[i1]) = iohelp.ReadBool(r)
	}
	bbp.A_byte = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.A_byte {
		(bbp.A_byte[i1]) = iohelp.ReadByte(r)
	}
	bbp.A_int16 = make([]int16, iohelp.ReadUint32(r))
	for i1 := range bbp.A_int16 {
		(bbp.A_int16[i1]) = iohelp.ReadInt16(r)
	}
	bbp.A_uint16 = make([]uint16, iohelp.ReadUint32(r))
	for i1 := range bbp.A_uint16 {
		(bbp.A_uint16[i1]) = iohelp.ReadUint16(r)
	}
	bbp.A_int32 = make([]int32, iohelp.ReadUint32(r))
	for i1 := range bbp.A_int32 {
		(bbp.A_int32[i1]) = iohelp.ReadInt32(r)
	}
	bbp.A_uint32 = make([]uint32, iohelp.ReadUint32(r))
	for i1 := range bbp.A_uint32 {
		(bbp.A_uint32[i1]) = iohelp.ReadUint32(r)
	}
	bbp.A_int64 = make([]int64, iohelp.ReadUint32(r))
	for i1 := range bbp.A_int64 {
		(bbp.A_int64[i1]) = iohelp.ReadInt64(r)
	}
	bbp.A_uint64 = make([]uint64, iohelp.ReadUint32(r))
	for i1 := range bbp.A_uint64 {
		(bbp.A_uint64[i1]) = iohelp.ReadUint64(r)
	}
	bbp.A_float32 = make([]float32, iohelp.ReadUint32(r))
	for i1 := range bbp.A_float32 {
		(bbp.A_float32[i1]) = iohelp.ReadFloat32(r)
	}
	bbp.A_float64 = make([]float64, iohelp.ReadUint32(r))
	for i1 := range bbp.A_float64 {
		(bbp.A_float64[i1]) = iohelp.ReadFloat64(r)
	}
	bbp.A_string = make([]string, iohelp.ReadUint32(r))
	for i1 := range bbp.A_string {
		(bbp.A_string[i1]) = iohelp.ReadString(r)
	}
	bbp.A_guid = make([][16]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.A_guid {
		(bbp.A_guid[i1]) = iohelp.ReadGUID(r)
	}
	return r.Err
}

func (bbp BasicArrays) Size() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.A_bool) * 1
	bodyLen += 4
	bodyLen += len(bbp.A_byte) * 1
	bodyLen += 4
	bodyLen += len(bbp.A_int16) * 2
	bodyLen += 4
	bodyLen += len(bbp.A_uint16) * 2
	bodyLen += 4
	bodyLen += len(bbp.A_int32) * 4
	bodyLen += 4
	bodyLen += len(bbp.A_uint32) * 4
	bodyLen += 4
	bodyLen += len(bbp.A_int64) * 8
	bodyLen += 4
	bodyLen += len(bbp.A_uint64) * 8
	bodyLen += 4
	bodyLen += len(bbp.A_float32) * 4
	bodyLen += 4
	bodyLen += len(bbp.A_float64) * 8
	bodyLen += 4
	for _, elem := range bbp.A_string {
		bodyLen += 4 + len(elem)
	}
	bodyLen += 4
	bodyLen += len(bbp.A_guid) * 16
	return bodyLen
}

func MakeBasicArrays(r iohelp.ErrorReader) (BasicArrays, error) {
	v := BasicArrays{}
	err := v.DecodeBebop(r)
	return v, err
}

func MakeBasicArraysFromBytes(buf []byte) (BasicArrays, error) {
	v := BasicArrays{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func MustMakeBasicArraysFromBytes(buf []byte) BasicArrays {
	v := BasicArrays{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &TestInt32Array{}

type TestInt32Array struct {
	A []int32
}

func (bbp TestInt32Array) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func (bbp TestInt32Array) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.A)))
	at += 4
	for _, v1 := range bbp.A {
		iohelp.WriteInt32Bytes(buf[at:], v1)
		at += 4
	}
	return at
}

func (bbp *TestInt32Array) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A = make([]int32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.A)*4 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.A {
		(bbp.A)[i1] = iohelp.ReadInt32Bytes(buf[at:])
		at += 4
	}
	return nil
}

func (bbp *TestInt32Array) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.A = make([]int32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.A {
		(bbp.A)[i1] = iohelp.ReadInt32Bytes(buf[at:])
		at += 4
	}
}

func (bbp TestInt32Array) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		iohelp.WriteInt32(w, elem)
	}
	return w.Err
}

func (bbp *TestInt32Array) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.A = make([]int32, iohelp.ReadUint32(r))
	for i1 := range bbp.A {
		(bbp.A[i1]) = iohelp.ReadInt32(r)
	}
	return r.Err
}

func (bbp TestInt32Array) Size() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.A) * 4
	return bodyLen
}

func MakeTestInt32Array(r iohelp.ErrorReader) (TestInt32Array, error) {
	v := TestInt32Array{}
	err := v.DecodeBebop(r)
	return v, err
}

func MakeTestInt32ArrayFromBytes(buf []byte) (TestInt32Array, error) {
	v := TestInt32Array{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func MustMakeTestInt32ArrayFromBytes(buf []byte) TestInt32Array {
	v := TestInt32Array{}
	v.MustUnmarshalBebop(buf)
	return v
}

