// Code generated by bebopc-go; DO NOT EDIT.

package generated

import (
	"bytes"
	"encoding/binary"
	"io"

	"github.com/200sc/bebop"
)

type VideoCodec uint32

const (
	VideoCodec_H264 VideoCodec = 0
	VideoCodec_H265 VideoCodec = 1
)

var _ bebop.Record = &Int32s{}

type Int32s struct {
	A []int32
}

func(bbp Int32s) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		binary.Write(w, binary.LittleEndian, elem)
	}
	return nil
}

func(bbp *Int32s) DecodeBebop(r io.Reader) (err error) {
	var ln uint32
	ln = uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	for i := uint32(0); i < ln; i++ {
		elem1 := new(int32)
		binary.Read(r, binary.LittleEndian, elem1)
		bbp.A = append(bbp.A, *elem1)
	}
	return nil
}

func(bbp *Int32s) bodyLen() (uint32) {
	bodyLen := uint32(0)
	bodyLen += 4
	for _ = range bbp.A {
		bodyLen += 4
	}
	return bodyLen
}

var _ bebop.Record = &Uint32s{}

type Uint32s struct {
	A []uint32
}

func(bbp Uint32s) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		binary.Write(w, binary.LittleEndian, elem)
	}
	return nil
}

func(bbp *Uint32s) DecodeBebop(r io.Reader) (err error) {
	var ln uint32
	ln = uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	for i := uint32(0); i < ln; i++ {
		elem1 := new(uint32)
		binary.Read(r, binary.LittleEndian, elem1)
		bbp.A = append(bbp.A, *elem1)
	}
	return nil
}

func(bbp *Uint32s) bodyLen() (uint32) {
	bodyLen := uint32(0)
	bodyLen += 4
	for _ = range bbp.A {
		bodyLen += 4
	}
	return bodyLen
}

var _ bebop.Record = &Float32s{}

type Float32s struct {
	A []float32
}

func(bbp Float32s) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		binary.Write(w, binary.LittleEndian, elem)
	}
	return nil
}

func(bbp *Float32s) DecodeBebop(r io.Reader) (err error) {
	var ln uint32
	ln = uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	for i := uint32(0); i < ln; i++ {
		elem1 := new(float32)
		binary.Read(r, binary.LittleEndian, elem1)
		bbp.A = append(bbp.A, *elem1)
	}
	return nil
}

func(bbp *Float32s) bodyLen() (uint32) {
	bodyLen := uint32(0)
	bodyLen += 4
	for _ = range bbp.A {
		bodyLen += 4
	}
	return bodyLen
}

var _ bebop.Record = &Int64s{}

type Int64s struct {
	A []int64
}

func(bbp Int64s) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		binary.Write(w, binary.LittleEndian, elem)
	}
	return nil
}

func(bbp *Int64s) DecodeBebop(r io.Reader) (err error) {
	var ln uint32
	ln = uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	for i := uint32(0); i < ln; i++ {
		elem1 := new(int64)
		binary.Read(r, binary.LittleEndian, elem1)
		bbp.A = append(bbp.A, *elem1)
	}
	return nil
}

func(bbp *Int64s) bodyLen() (uint32) {
	bodyLen := uint32(0)
	bodyLen += 4
	for _ = range bbp.A {
		bodyLen += 8
	}
	return bodyLen
}

var _ bebop.Record = &Uint64s{}

type Uint64s struct {
	A []uint64
}

func(bbp Uint64s) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		binary.Write(w, binary.LittleEndian, elem)
	}
	return nil
}

func(bbp *Uint64s) DecodeBebop(r io.Reader) (err error) {
	var ln uint32
	ln = uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	for i := uint32(0); i < ln; i++ {
		elem1 := new(uint64)
		binary.Read(r, binary.LittleEndian, elem1)
		bbp.A = append(bbp.A, *elem1)
	}
	return nil
}

func(bbp *Uint64s) bodyLen() (uint32) {
	bodyLen := uint32(0)
	bodyLen += 4
	for _ = range bbp.A {
		bodyLen += 8
	}
	return bodyLen
}

var _ bebop.Record = &Float64s{}

type Float64s struct {
	A []float64
}

func(bbp Float64s) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		binary.Write(w, binary.LittleEndian, elem)
	}
	return nil
}

func(bbp *Float64s) DecodeBebop(r io.Reader) (err error) {
	var ln uint32
	ln = uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	for i := uint32(0); i < ln; i++ {
		elem1 := new(float64)
		binary.Read(r, binary.LittleEndian, elem1)
		bbp.A = append(bbp.A, *elem1)
	}
	return nil
}

func(bbp *Float64s) bodyLen() (uint32) {
	bodyLen := uint32(0)
	bodyLen += 4
	for _ = range bbp.A {
		bodyLen += 8
	}
	return bodyLen
}

var _ bebop.Record = &VideoData{}

type VideoData struct {
	Time float64
	Width uint32
	Height uint32
	Fragment []byte
}

func(bbp VideoData) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, bbp.Time)
	binary.Write(w, binary.LittleEndian, bbp.Width)
	binary.Write(w, binary.LittleEndian, bbp.Height)
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.Fragment)))
	for _, elem := range bbp.Fragment {
		binary.Write(w, binary.LittleEndian, elem)
	}
	return nil
}

func(bbp *VideoData) DecodeBebop(r io.Reader) (err error) {
	var ln uint32
	binary.Read(r, binary.LittleEndian, &bbp.Time)
	binary.Read(r, binary.LittleEndian, &bbp.Width)
	binary.Read(r, binary.LittleEndian, &bbp.Height)
	ln = uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	for i := uint32(0); i < ln; i++ {
		elem1 := new(byte)
		binary.Read(r, binary.LittleEndian, elem1)
		bbp.Fragment = append(bbp.Fragment, *elem1)
	}
	return nil
}

func(bbp *VideoData) bodyLen() (uint32) {
	bodyLen := uint32(0)
	bodyLen += 8
	bodyLen += 4
	bodyLen += 4
	bodyLen += 4
	for _ = range bbp.Fragment {
		bodyLen += 1
	}
	return bodyLen
}

var _ bebop.Record = &MediaMessage{}

type MediaMessage struct {
	Codec *VideoCodec
	Data *VideoData
}

func(bbp MediaMessage) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, bbp.bodyLen())
	if bbp.Codec != nil {
		w.Write([]byte{1})
		binary.Write(w, binary.LittleEndian, uint32(*bbp.Codec))
	}
	if bbp.Data != nil {
		w.Write([]byte{2})
		err = (*bbp.Data).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	w.Write([]byte{0})
	return nil
}

func(bbp *MediaMessage) DecodeBebop(ior io.Reader) (err error) {
	var bodyLen uint32
	var fieldNum byte
	binary.Read(ior, binary.LittleEndian, &bodyLen)
	body := make([]byte, bodyLen)
	ior.Read(body)
	r := bytes.NewReader(body)
	for r.Len() > 1 {
		fieldNum, _ = r.ReadByte()
		switch fieldNum {
		case 1:
			bbp.Codec = new(VideoCodec)
			binary.Read(r, binary.LittleEndian, bbp.Codec)
		case 2:
			bbp.Data = new(VideoData)
			err = (bbp.Data).DecodeBebop(r)
			if err != nil {
				return err
			}
		default:
			return nil
		}
	}
	return nil
}

func(bbp *MediaMessage) bodyLen() (uint32) {
	bodyLen := uint32(1)
	if bbp.Codec != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.Data != nil {
		bodyLen += 1
		bodyLen += (*bbp.Data).bodyLen()
	}
	return bodyLen
}

//  Should be able to decode a "SkipTestNewContainer" as a "SkipTestOldContainer".
var _ bebop.Record = &SkipTestOld{}

type SkipTestOld struct {
	X *int32
	Y *int32
}

func(bbp SkipTestOld) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, bbp.bodyLen())
	if bbp.X != nil {
		w.Write([]byte{1})
		binary.Write(w, binary.LittleEndian, *bbp.X)
	}
	if bbp.Y != nil {
		w.Write([]byte{2})
		binary.Write(w, binary.LittleEndian, *bbp.Y)
	}
	w.Write([]byte{0})
	return nil
}

func(bbp *SkipTestOld) DecodeBebop(ior io.Reader) (err error) {
	var bodyLen uint32
	var fieldNum byte
	binary.Read(ior, binary.LittleEndian, &bodyLen)
	body := make([]byte, bodyLen)
	ior.Read(body)
	r := bytes.NewReader(body)
	for r.Len() > 1 {
		fieldNum, _ = r.ReadByte()
		switch fieldNum {
		case 1:
			bbp.X = new(int32)
			binary.Read(r, binary.LittleEndian, bbp.X)
		case 2:
			bbp.Y = new(int32)
			binary.Read(r, binary.LittleEndian, bbp.Y)
		default:
			return nil
		}
	}
	return nil
}

func(bbp *SkipTestOld) bodyLen() (uint32) {
	bodyLen := uint32(1)
	if bbp.X != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.Y != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

var _ bebop.Record = &SkipTestNew{}

type SkipTestNew struct {
	X *int32
	Y *int32
	Z *int32
}

func(bbp SkipTestNew) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, bbp.bodyLen())
	if bbp.X != nil {
		w.Write([]byte{1})
		binary.Write(w, binary.LittleEndian, *bbp.X)
	}
	if bbp.Y != nil {
		w.Write([]byte{2})
		binary.Write(w, binary.LittleEndian, *bbp.Y)
	}
	if bbp.Z != nil {
		w.Write([]byte{3})
		binary.Write(w, binary.LittleEndian, *bbp.Z)
	}
	w.Write([]byte{0})
	return nil
}

func(bbp *SkipTestNew) DecodeBebop(ior io.Reader) (err error) {
	var bodyLen uint32
	var fieldNum byte
	binary.Read(ior, binary.LittleEndian, &bodyLen)
	body := make([]byte, bodyLen)
	ior.Read(body)
	r := bytes.NewReader(body)
	for r.Len() > 1 {
		fieldNum, _ = r.ReadByte()
		switch fieldNum {
		case 1:
			bbp.X = new(int32)
			binary.Read(r, binary.LittleEndian, bbp.X)
		case 2:
			bbp.Y = new(int32)
			binary.Read(r, binary.LittleEndian, bbp.Y)
		case 3:
			bbp.Z = new(int32)
			binary.Read(r, binary.LittleEndian, bbp.Z)
		default:
			return nil
		}
	}
	return nil
}

func(bbp *SkipTestNew) bodyLen() (uint32) {
	bodyLen := uint32(1)
	if bbp.X != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.Y != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.Z != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

var _ bebop.Record = &SkipTestOldContainer{}

type SkipTestOldContainer struct {
	S *SkipTestOld
	After *int32
}

func(bbp SkipTestOldContainer) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, bbp.bodyLen())
	if bbp.S != nil {
		w.Write([]byte{1})
		err = (*bbp.S).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	if bbp.After != nil {
		w.Write([]byte{2})
		binary.Write(w, binary.LittleEndian, *bbp.After)
	}
	w.Write([]byte{0})
	return nil
}

func(bbp *SkipTestOldContainer) DecodeBebop(ior io.Reader) (err error) {
	var bodyLen uint32
	var fieldNum byte
	binary.Read(ior, binary.LittleEndian, &bodyLen)
	body := make([]byte, bodyLen)
	ior.Read(body)
	r := bytes.NewReader(body)
	for r.Len() > 1 {
		fieldNum, _ = r.ReadByte()
		switch fieldNum {
		case 1:
			bbp.S = new(SkipTestOld)
			err = (bbp.S).DecodeBebop(r)
			if err != nil {
				return err
			}
		case 2:
			bbp.After = new(int32)
			binary.Read(r, binary.LittleEndian, bbp.After)
		default:
			return nil
		}
	}
	return nil
}

func(bbp *SkipTestOldContainer) bodyLen() (uint32) {
	bodyLen := uint32(1)
	if bbp.S != nil {
		bodyLen += 1
		bodyLen += (*bbp.S).bodyLen()
	}
	if bbp.After != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

var _ bebop.Record = &SkipTestNewContainer{}

type SkipTestNewContainer struct {
	S *SkipTestNew
	After *int32
}

func(bbp SkipTestNewContainer) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, bbp.bodyLen())
	if bbp.S != nil {
		w.Write([]byte{1})
		err = (*bbp.S).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	if bbp.After != nil {
		w.Write([]byte{2})
		binary.Write(w, binary.LittleEndian, *bbp.After)
	}
	w.Write([]byte{0})
	return nil
}

func(bbp *SkipTestNewContainer) DecodeBebop(ior io.Reader) (err error) {
	var bodyLen uint32
	var fieldNum byte
	binary.Read(ior, binary.LittleEndian, &bodyLen)
	body := make([]byte, bodyLen)
	ior.Read(body)
	r := bytes.NewReader(body)
	for r.Len() > 1 {
		fieldNum, _ = r.ReadByte()
		switch fieldNum {
		case 1:
			bbp.S = new(SkipTestNew)
			err = (bbp.S).DecodeBebop(r)
			if err != nil {
				return err
			}
		case 2:
			bbp.After = new(int32)
			binary.Read(r, binary.LittleEndian, bbp.After)
		default:
			return nil
		}
	}
	return nil
}

func(bbp *SkipTestNewContainer) bodyLen() (uint32) {
	bodyLen := uint32(1)
	if bbp.S != nil {
		bodyLen += 1
		bodyLen += (*bbp.S).bodyLen()
	}
	if bbp.After != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

