// Code generated by bebopc-go; DO NOT EDIT.

package generated

import (
	"bytes"
	"encoding/binary"
	"io"

	"github.com/200sc/bebop"
	"github.com/200sc/bebop/iohelp"
)

type VideoCodec uint32

const (
	VideoCodec_H264 VideoCodec = 0
	VideoCodec_H265 VideoCodec = 1
)

var _ bebop.Record = &Int32s{}

type Int32s struct {
	A []int32
}

func (bbp Int32s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		iohelp.WriteInt32(w, elem)
	}
	return w.Err
}

func (bbp *Int32s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.A = make([]int32, iohelp.ReadUint32(r))
	for i1 := range bbp.A {
		(bbp.A[i1]) = iohelp.ReadInt32(r)
	}
	return r.Err
}

func (bbp *Int32s) bodyLen() uint32 {
	bodyLen := uint32(0)
	bodyLen += 4
	for range bbp.A {
		bodyLen += 4
	}
	return bodyLen
}

func makeInt32s(r iohelp.ErrorReader) (Int32s, error) {
	v := Int32s{}
	err := v.DecodeBebop(r)
	return v, err
}

var _ bebop.Record = &Uint32s{}

type Uint32s struct {
	A []uint32
}

func (bbp Uint32s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		iohelp.WriteUint32(w, elem)
	}
	return w.Err
}

func (bbp *Uint32s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.A = make([]uint32, iohelp.ReadUint32(r))
	for i1 := range bbp.A {
		(bbp.A[i1]) = iohelp.ReadUint32(r)
	}
	return r.Err
}

func (bbp *Uint32s) bodyLen() uint32 {
	bodyLen := uint32(0)
	bodyLen += 4
	for range bbp.A {
		bodyLen += 4
	}
	return bodyLen
}

func makeUint32s(r iohelp.ErrorReader) (Uint32s, error) {
	v := Uint32s{}
	err := v.DecodeBebop(r)
	return v, err
}

var _ bebop.Record = &Float32s{}

type Float32s struct {
	A []float32
}

func (bbp Float32s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		iohelp.WriteFloat32(w, elem)
	}
	return w.Err
}

func (bbp *Float32s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.A = make([]float32, iohelp.ReadUint32(r))
	for i1 := range bbp.A {
		(bbp.A[i1]) = iohelp.ReadFloat32(r)
	}
	return r.Err
}

func (bbp *Float32s) bodyLen() uint32 {
	bodyLen := uint32(0)
	bodyLen += 4
	for range bbp.A {
		bodyLen += 4
	}
	return bodyLen
}

func makeFloat32s(r iohelp.ErrorReader) (Float32s, error) {
	v := Float32s{}
	err := v.DecodeBebop(r)
	return v, err
}

var _ bebop.Record = &Int64s{}

type Int64s struct {
	A []int64
}

func (bbp Int64s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		iohelp.WriteInt64(w, elem)
	}
	return w.Err
}

func (bbp *Int64s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.A = make([]int64, iohelp.ReadUint32(r))
	for i1 := range bbp.A {
		(bbp.A[i1]) = iohelp.ReadInt64(r)
	}
	return r.Err
}

func (bbp *Int64s) bodyLen() uint32 {
	bodyLen := uint32(0)
	bodyLen += 4
	for range bbp.A {
		bodyLen += 8
	}
	return bodyLen
}

func makeInt64s(r iohelp.ErrorReader) (Int64s, error) {
	v := Int64s{}
	err := v.DecodeBebop(r)
	return v, err
}

var _ bebop.Record = &Uint64s{}

type Uint64s struct {
	A []uint64
}

func (bbp Uint64s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		iohelp.WriteUint64(w, elem)
	}
	return w.Err
}

func (bbp *Uint64s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.A = make([]uint64, iohelp.ReadUint32(r))
	for i1 := range bbp.A {
		(bbp.A[i1]) = iohelp.ReadUint64(r)
	}
	return r.Err
}

func (bbp *Uint64s) bodyLen() uint32 {
	bodyLen := uint32(0)
	bodyLen += 4
	for range bbp.A {
		bodyLen += 8
	}
	return bodyLen
}

func makeUint64s(r iohelp.ErrorReader) (Uint64s, error) {
	v := Uint64s{}
	err := v.DecodeBebop(r)
	return v, err
}

var _ bebop.Record = &Float64s{}

type Float64s struct {
	A []float64
}

func (bbp Float64s) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.A)))
	for _, elem := range bbp.A {
		iohelp.WriteFloat64(w, elem)
	}
	return w.Err
}

func (bbp *Float64s) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.A = make([]float64, iohelp.ReadUint32(r))
	for i1 := range bbp.A {
		(bbp.A[i1]) = iohelp.ReadFloat64(r)
	}
	return r.Err
}

func (bbp *Float64s) bodyLen() uint32 {
	bodyLen := uint32(0)
	bodyLen += 4
	for range bbp.A {
		bodyLen += 8
	}
	return bodyLen
}

func makeFloat64s(r iohelp.ErrorReader) (Float64s, error) {
	v := Float64s{}
	err := v.DecodeBebop(r)
	return v, err
}

var _ bebop.Record = &VideoData{}

type VideoData struct {
	Time float64
	Width uint32
	Height uint32
	Fragment []byte
}

func (bbp VideoData) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteFloat64(w, bbp.Time)
	iohelp.WriteUint32(w, bbp.Width)
	iohelp.WriteUint32(w, bbp.Height)
	iohelp.WriteUint32(w, uint32(len(bbp.Fragment)))
	for _, elem := range bbp.Fragment {
		iohelp.WriteByte(w, elem)
	}
	return w.Err
}

func (bbp *VideoData) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.Time = iohelp.ReadFloat64(r)
	bbp.Width = iohelp.ReadUint32(r)
	bbp.Height = iohelp.ReadUint32(r)
	bbp.Fragment = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Fragment {
		(bbp.Fragment[i1]) = iohelp.ReadByte(r)
	}
	return r.Err
}

func (bbp *VideoData) bodyLen() uint32 {
	bodyLen := uint32(0)
	bodyLen += 8
	bodyLen += 4
	bodyLen += 4
	bodyLen += 4
	for range bbp.Fragment {
		bodyLen += 1
	}
	return bodyLen
}

func makeVideoData(r iohelp.ErrorReader) (VideoData, error) {
	v := VideoData{}
	err := v.DecodeBebop(r)
	return v, err
}

var _ bebop.Record = &MediaMessage{}

type MediaMessage struct {
	Codec *VideoCodec
	Data *VideoData
}

func (bbp MediaMessage) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	binary.Write(w, binary.LittleEndian, bbp.bodyLen())
	if bbp.Codec != nil {
		w.Write([]byte{1})
		iohelp.WriteUint32(w, uint32(*bbp.Codec))
	}
	if bbp.Data != nil {
		w.Write([]byte{2})
		err = (*bbp.Data).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *MediaMessage) DecodeBebop(ior io.Reader) (err error) {
	er := iohelp.NewErrorReader(ior)
	bodyLen := iohelp.ReadUint32(er)
	body := make([]byte, bodyLen)
	er.Read(body)
	r := iohelp.NewErrorReader(bytes.NewReader(body))
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.Codec = new(VideoCodec)
			binary.Read(r, binary.LittleEndian, bbp.Codec)
		case 2:
			bbp.Data = new(VideoData)
			(*bbp.Data), err = makeVideoData(r)
			if err != nil {
				return err
			}
		default:
			return er.Err
		}
	}
}

func (bbp *MediaMessage) bodyLen() uint32 {
	bodyLen := uint32(1)
	if bbp.Codec != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.Data != nil {
		bodyLen += 1
		bodyLen += (*bbp.Data).bodyLen()
	}
	return bodyLen
}

func makeMediaMessage(r iohelp.ErrorReader) (MediaMessage, error) {
	v := MediaMessage{}
	err := v.DecodeBebop(r)
	return v, err
}

var _ bebop.Record = &SkipTestOld{}

// Should be able to decode a "SkipTestNewContainer" as a "SkipTestOldContainer".
type SkipTestOld struct {
	X *int32
	Y *int32
}

func (bbp SkipTestOld) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	binary.Write(w, binary.LittleEndian, bbp.bodyLen())
	if bbp.X != nil {
		w.Write([]byte{1})
		iohelp.WriteInt32(w, *bbp.X)
	}
	if bbp.Y != nil {
		w.Write([]byte{2})
		iohelp.WriteInt32(w, *bbp.Y)
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *SkipTestOld) DecodeBebop(ior io.Reader) (err error) {
	er := iohelp.NewErrorReader(ior)
	bodyLen := iohelp.ReadUint32(er)
	body := make([]byte, bodyLen)
	er.Read(body)
	r := iohelp.NewErrorReader(bytes.NewReader(body))
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.X = new(int32)
			*bbp.X = iohelp.ReadInt32(r)
		case 2:
			bbp.Y = new(int32)
			*bbp.Y = iohelp.ReadInt32(r)
		default:
			return er.Err
		}
	}
}

func (bbp *SkipTestOld) bodyLen() uint32 {
	bodyLen := uint32(1)
	if bbp.X != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.Y != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

func makeSkipTestOld(r iohelp.ErrorReader) (SkipTestOld, error) {
	v := SkipTestOld{}
	err := v.DecodeBebop(r)
	return v, err
}

var _ bebop.Record = &SkipTestNew{}

type SkipTestNew struct {
	X *int32
	Y *int32
	Z *int32
}

func (bbp SkipTestNew) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	binary.Write(w, binary.LittleEndian, bbp.bodyLen())
	if bbp.X != nil {
		w.Write([]byte{1})
		iohelp.WriteInt32(w, *bbp.X)
	}
	if bbp.Y != nil {
		w.Write([]byte{2})
		iohelp.WriteInt32(w, *bbp.Y)
	}
	if bbp.Z != nil {
		w.Write([]byte{3})
		iohelp.WriteInt32(w, *bbp.Z)
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *SkipTestNew) DecodeBebop(ior io.Reader) (err error) {
	er := iohelp.NewErrorReader(ior)
	bodyLen := iohelp.ReadUint32(er)
	body := make([]byte, bodyLen)
	er.Read(body)
	r := iohelp.NewErrorReader(bytes.NewReader(body))
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.X = new(int32)
			*bbp.X = iohelp.ReadInt32(r)
		case 2:
			bbp.Y = new(int32)
			*bbp.Y = iohelp.ReadInt32(r)
		case 3:
			bbp.Z = new(int32)
			*bbp.Z = iohelp.ReadInt32(r)
		default:
			return er.Err
		}
	}
}

func (bbp *SkipTestNew) bodyLen() uint32 {
	bodyLen := uint32(1)
	if bbp.X != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.Y != nil {
		bodyLen += 1
		bodyLen += 4
	}
	if bbp.Z != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

func makeSkipTestNew(r iohelp.ErrorReader) (SkipTestNew, error) {
	v := SkipTestNew{}
	err := v.DecodeBebop(r)
	return v, err
}

var _ bebop.Record = &SkipTestOldContainer{}

type SkipTestOldContainer struct {
	S *SkipTestOld
	After *int32
}

func (bbp SkipTestOldContainer) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	binary.Write(w, binary.LittleEndian, bbp.bodyLen())
	if bbp.S != nil {
		w.Write([]byte{1})
		err = (*bbp.S).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	if bbp.After != nil {
		w.Write([]byte{2})
		iohelp.WriteInt32(w, *bbp.After)
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *SkipTestOldContainer) DecodeBebop(ior io.Reader) (err error) {
	er := iohelp.NewErrorReader(ior)
	bodyLen := iohelp.ReadUint32(er)
	body := make([]byte, bodyLen)
	er.Read(body)
	r := iohelp.NewErrorReader(bytes.NewReader(body))
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.S = new(SkipTestOld)
			(*bbp.S), err = makeSkipTestOld(r)
			if err != nil {
				return err
			}
		case 2:
			bbp.After = new(int32)
			*bbp.After = iohelp.ReadInt32(r)
		default:
			return er.Err
		}
	}
}

func (bbp *SkipTestOldContainer) bodyLen() uint32 {
	bodyLen := uint32(1)
	if bbp.S != nil {
		bodyLen += 1
		bodyLen += (*bbp.S).bodyLen()
	}
	if bbp.After != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

func makeSkipTestOldContainer(r iohelp.ErrorReader) (SkipTestOldContainer, error) {
	v := SkipTestOldContainer{}
	err := v.DecodeBebop(r)
	return v, err
}

var _ bebop.Record = &SkipTestNewContainer{}

type SkipTestNewContainer struct {
	S *SkipTestNew
	After *int32
}

func (bbp SkipTestNewContainer) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	binary.Write(w, binary.LittleEndian, bbp.bodyLen())
	if bbp.S != nil {
		w.Write([]byte{1})
		err = (*bbp.S).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	if bbp.After != nil {
		w.Write([]byte{2})
		iohelp.WriteInt32(w, *bbp.After)
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *SkipTestNewContainer) DecodeBebop(ior io.Reader) (err error) {
	er := iohelp.NewErrorReader(ior)
	bodyLen := iohelp.ReadUint32(er)
	body := make([]byte, bodyLen)
	er.Read(body)
	r := iohelp.NewErrorReader(bytes.NewReader(body))
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.S = new(SkipTestNew)
			(*bbp.S), err = makeSkipTestNew(r)
			if err != nil {
				return err
			}
		case 2:
			bbp.After = new(int32)
			*bbp.After = iohelp.ReadInt32(r)
		default:
			return er.Err
		}
	}
}

func (bbp *SkipTestNewContainer) bodyLen() uint32 {
	bodyLen := uint32(1)
	if bbp.S != nil {
		bodyLen += 1
		bodyLen += (*bbp.S).bodyLen()
	}
	if bbp.After != nil {
		bodyLen += 1
		bodyLen += 4
	}
	return bodyLen
}

func makeSkipTestNewContainer(r iohelp.ErrorReader) (SkipTestNewContainer, error) {
	v := SkipTestNewContainer{}
	err := v.DecodeBebop(r)
	return v, err
}

