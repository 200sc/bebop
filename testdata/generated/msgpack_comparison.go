// Code generated by bebopc-go; DO NOT EDIT.

package generated

import (
	"encoding/binary"
	"io"

	"github.com/200sc/bebop"
	"github.com/200sc/bebop/iohelp"
)

//  key names in JSON to be the same length while not coinciding with Bebop keywords.
var _ bebop.Record = &MsgpackComparison{}

type MsgpackComparison struct {
	INT0 uint8
	INT1 uint8
	INT1_ int16
	INT8 uint8
	INT8_ int16
	INT16 int16
	INT16_ int16
	INT32 int32
	INT32_ int32
	//  int8 nIL; // "nil": null,
	TRUE bool
	FALSE bool
	FLOAT float64
	FLOAT_ float64
	STRING0 string
	STRING1 string
	STRING4 string
	STRING8 string
	STRING16 string
	ARRAY0 []int32
	ARRAY1 []string
	ARRAY8 []int32
}

func(bbp MsgpackComparison) EncodeBebop(w io.Writer) (err error) {
	binary.Write(w, binary.LittleEndian, bbp.INT0)
	binary.Write(w, binary.LittleEndian, bbp.INT1)
	binary.Write(w, binary.LittleEndian, bbp.INT1_)
	binary.Write(w, binary.LittleEndian, bbp.INT8)
	binary.Write(w, binary.LittleEndian, bbp.INT8_)
	binary.Write(w, binary.LittleEndian, bbp.INT16)
	binary.Write(w, binary.LittleEndian, bbp.INT16_)
	binary.Write(w, binary.LittleEndian, bbp.INT32)
	binary.Write(w, binary.LittleEndian, bbp.INT32_)
	binary.Write(w, binary.LittleEndian, bbp.TRUE)
	binary.Write(w, binary.LittleEndian, bbp.FALSE)
	binary.Write(w, binary.LittleEndian, bbp.FLOAT)
	binary.Write(w, binary.LittleEndian, bbp.FLOAT_)
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.STRING0)))
	w.Write([]byte(bbp.STRING0))
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.STRING1)))
	w.Write([]byte(bbp.STRING1))
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.STRING4)))
	w.Write([]byte(bbp.STRING4))
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.STRING8)))
	w.Write([]byte(bbp.STRING8))
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.STRING16)))
	w.Write([]byte(bbp.STRING16))
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.ARRAY0)))
	for _, elem := range bbp.ARRAY0 {
		binary.Write(w, binary.LittleEndian, elem)
	}
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.ARRAY1)))
	for _, elem := range bbp.ARRAY1 {
		binary.Write(w, binary.LittleEndian, uint32(len(elem)))
		w.Write([]byte(elem))
	}
	binary.Write(w, binary.LittleEndian, uint32(len(bbp.ARRAY8)))
	for _, elem := range bbp.ARRAY8 {
		binary.Write(w, binary.LittleEndian, elem)
	}
	return nil
}

func(bbp *MsgpackComparison) DecodeBebop(r io.Reader) (err error) {
	var ln uint32
	binary.Read(r, binary.LittleEndian, &bbp.INT0)
	binary.Read(r, binary.LittleEndian, &bbp.INT1)
	binary.Read(r, binary.LittleEndian, &bbp.INT1_)
	binary.Read(r, binary.LittleEndian, &bbp.INT8)
	binary.Read(r, binary.LittleEndian, &bbp.INT8_)
	binary.Read(r, binary.LittleEndian, &bbp.INT16)
	binary.Read(r, binary.LittleEndian, &bbp.INT16_)
	binary.Read(r, binary.LittleEndian, &bbp.INT32)
	binary.Read(r, binary.LittleEndian, &bbp.INT32_)
	binary.Read(r, binary.LittleEndian, &bbp.TRUE)
	binary.Read(r, binary.LittleEndian, &bbp.FALSE)
	binary.Read(r, binary.LittleEndian, &bbp.FLOAT)
	binary.Read(r, binary.LittleEndian, &bbp.FLOAT_)
	bbp.STRING0 = iohelp.ReadString(r)
	bbp.STRING1 = iohelp.ReadString(r)
	bbp.STRING4 = iohelp.ReadString(r)
	bbp.STRING8 = iohelp.ReadString(r)
	bbp.STRING16 = iohelp.ReadString(r)
	ln = uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	for i := uint32(0); i < ln; i++ {
		elem1 := new(int32)
		binary.Read(r, binary.LittleEndian, elem1)
		bbp.ARRAY0 = append(bbp.ARRAY0, *elem1)
	}
	ln = uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	for i := uint32(0); i < ln; i++ {
		elem1 := new(string)
		*elem1 = iohelp.ReadString(r)
		bbp.ARRAY1 = append(bbp.ARRAY1, *elem1)
	}
	ln = uint32(0)
	binary.Read(r, binary.LittleEndian, &ln)
	for i := uint32(0); i < ln; i++ {
		elem1 := new(int32)
		binary.Read(r, binary.LittleEndian, elem1)
		bbp.ARRAY8 = append(bbp.ARRAY8, *elem1)
	}
	return nil
}

func(bbp *MsgpackComparison) bodyLen() (uint32) {
	bodyLen := uint32(0)
	bodyLen += 1
	bodyLen += 1
	bodyLen += 2
	bodyLen += 1
	bodyLen += 2
	bodyLen += 2
	bodyLen += 2
	bodyLen += 4
	bodyLen += 4
	bodyLen += 1
	bodyLen += 1
	bodyLen += 8
	bodyLen += 8
	bodyLen += 4
	bodyLen += uint32(len(bbp.STRING0))
	bodyLen += 4
	bodyLen += uint32(len(bbp.STRING1))
	bodyLen += 4
	bodyLen += uint32(len(bbp.STRING4))
	bodyLen += 4
	bodyLen += uint32(len(bbp.STRING8))
	bodyLen += 4
	bodyLen += uint32(len(bbp.STRING16))
	bodyLen += 4
	for _ = range bbp.ARRAY0 {
		bodyLen += 4
	}
	bodyLen += 4
	for _, elem := range bbp.ARRAY1 {
		bodyLen += 4
		bodyLen += uint32(len(elem))
	}
	bodyLen += 4
	for _ = range bbp.ARRAY8 {
		bodyLen += 4
	}
	return bodyLen
}

