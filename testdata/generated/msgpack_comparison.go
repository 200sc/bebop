// Code generated by bebopc-go; DO NOT EDIT.

package generated

import (
	"io"

	"github.com/200sc/bebop"
	"github.com/200sc/bebop/iohelp"
)

var _ bebop.Record = &MsgpackComparison{}

// These field names are extremely weirdly capitalized, because I wanted the
// key names in JSON to be the same length while not coinciding with Bebop keywords.
type MsgpackComparison struct {
	INT0 uint8
	INT1 uint8
	INT1_ int16
	INT8 uint8
	INT8_ int16
	INT16 int16
	INT16_ int16
	INT32 int32
	INT32_ int32
	// int8 nIL; // "nil": null,
	TRUE bool
	FALSE bool
	FLOAT float64
	FLOAT_ float64
	STRING0 string
	STRING1 string
	STRING4 string
	STRING8 string
	STRING16 string
	ARRAY0 []int32
	ARRAY1 []string
	ARRAY8 []int32
}

func (bbp MsgpackComparison) MarshalBebop() []byte {
	buf := make([]byte, bbp.bodyLen())
	bbp.MarshalBebopTo(buf)
	return buf
}

func (bbp MsgpackComparison) MarshalBebopTo(buf []byte) {
	at := 0
	iohelp.WriteUint8Bytes(buf[at:], bbp.INT0)
	at += 1
	iohelp.WriteUint8Bytes(buf[at:], bbp.INT1)
	at += 1
	iohelp.WriteInt16Bytes(buf[at:], bbp.INT1_)
	at += 2
	iohelp.WriteUint8Bytes(buf[at:], bbp.INT8)
	at += 1
	iohelp.WriteInt16Bytes(buf[at:], bbp.INT8_)
	at += 2
	iohelp.WriteInt16Bytes(buf[at:], bbp.INT16)
	at += 2
	iohelp.WriteInt16Bytes(buf[at:], bbp.INT16_)
	at += 2
	iohelp.WriteInt32Bytes(buf[at:], bbp.INT32)
	at += 4
	iohelp.WriteInt32Bytes(buf[at:], bbp.INT32_)
	at += 4
	iohelp.WriteBoolBytes(buf[at:], bbp.TRUE)
	at += 1
	iohelp.WriteBoolBytes(buf[at:], bbp.FALSE)
	at += 1
	iohelp.WriteFloat64Bytes(buf[at:], bbp.FLOAT)
	at += 8
	iohelp.WriteFloat64Bytes(buf[at:], bbp.FLOAT_)
	at += 8
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.STRING0)))
	at += 4
	copy(buf[at:at+len(bbp.STRING0)], []byte(bbp.STRING0))
	at += len(bbp.STRING0)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.STRING1)))
	at += 4
	copy(buf[at:at+len(bbp.STRING1)], []byte(bbp.STRING1))
	at += len(bbp.STRING1)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.STRING4)))
	at += 4
	copy(buf[at:at+len(bbp.STRING4)], []byte(bbp.STRING4))
	at += len(bbp.STRING4)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.STRING8)))
	at += 4
	copy(buf[at:at+len(bbp.STRING8)], []byte(bbp.STRING8))
	at += len(bbp.STRING8)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.STRING16)))
	at += 4
	copy(buf[at:at+len(bbp.STRING16)], []byte(bbp.STRING16))
	at += len(bbp.STRING16)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.ARRAY0)))
	at += 4
	for _, v1 := range bbp.ARRAY0 {
		iohelp.WriteInt32Bytes(buf[at:], v1)
		at += 4
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.ARRAY1)))
	at += 4
	for _, v1 := range bbp.ARRAY1 {
		iohelp.WriteUint32Bytes(buf[at:], uint32(len(v1)))
		at += 4
		copy(buf[at:at+len(v1)], []byte(v1))
		at += len(v1)
	}
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.ARRAY8)))
	at += 4
	for _, v1 := range bbp.ARRAY8 {
		iohelp.WriteInt32Bytes(buf[at:], v1)
		at += 4
	}
}

func (bbp *MsgpackComparison) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 1 {
		 return iohelp.ErrTooShort
	}
	bbp.INT0 = iohelp.ReadUint8Bytes(buf[at:])
	at += 1
	if len(buf[at:]) < 1 {
		 return iohelp.ErrTooShort
	}
	bbp.INT1 = iohelp.ReadUint8Bytes(buf[at:])
	at += 1
	if len(buf[at:]) < 2 {
		 return iohelp.ErrTooShort
	}
	bbp.INT1_ = iohelp.ReadInt16Bytes(buf[at:])
	at += 2
	if len(buf[at:]) < 1 {
		 return iohelp.ErrTooShort
	}
	bbp.INT8 = iohelp.ReadUint8Bytes(buf[at:])
	at += 1
	if len(buf[at:]) < 2 {
		 return iohelp.ErrTooShort
	}
	bbp.INT8_ = iohelp.ReadInt16Bytes(buf[at:])
	at += 2
	if len(buf[at:]) < 2 {
		 return iohelp.ErrTooShort
	}
	bbp.INT16 = iohelp.ReadInt16Bytes(buf[at:])
	at += 2
	if len(buf[at:]) < 2 {
		 return iohelp.ErrTooShort
	}
	bbp.INT16_ = iohelp.ReadInt16Bytes(buf[at:])
	at += 2
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.INT32 = iohelp.ReadInt32Bytes(buf[at:])
	at += 4
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.INT32_ = iohelp.ReadInt32Bytes(buf[at:])
	at += 4
	if len(buf[at:]) < 1 {
		 return iohelp.ErrTooShort
	}
	bbp.TRUE = iohelp.ReadBoolBytes(buf[at:])
	at += 1
	if len(buf[at:]) < 1 {
		 return iohelp.ErrTooShort
	}
	bbp.FALSE = iohelp.ReadBoolBytes(buf[at:])
	at += 1
	if len(buf[at:]) < 8 {
		 return iohelp.ErrTooShort
	}
	bbp.FLOAT = iohelp.ReadFloat64Bytes(buf[at:])
	at += 8
	if len(buf[at:]) < 8 {
		 return iohelp.ErrTooShort
	}
	bbp.FLOAT_ = iohelp.ReadFloat64Bytes(buf[at:])
	at += 8
	bbp.STRING0, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		 return err
	}
	at += 4 + len(bbp.STRING0)
	bbp.STRING1, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		 return err
	}
	at += 4 + len(bbp.STRING1)
	bbp.STRING4, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		 return err
	}
	at += 4 + len(bbp.STRING4)
	bbp.STRING8, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		 return err
	}
	at += 4 + len(bbp.STRING8)
	bbp.STRING16, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		 return err
	}
	at += 4 + len(bbp.STRING16)
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.ARRAY0 = make([]int32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.ARRAY0)*4 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.ARRAY0 {
		(bbp.ARRAY0)[i1] = iohelp.ReadInt32Bytes(buf[at:])
		at += 4
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.ARRAY1 = make([]string, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.ARRAY1 {
		(bbp.ARRAY1)[i1], err = iohelp.ReadStringBytes(buf[at:])
		if err != nil {
			 return err
		}
		at += 4 + len((bbp.ARRAY1)[i1])
	}
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.ARRAY8 = make([]int32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.ARRAY8)*4 {
		 return iohelp.ErrTooShort
	}
	for i1 := range bbp.ARRAY8 {
		(bbp.ARRAY8)[i1] = iohelp.ReadInt32Bytes(buf[at:])
		at += 4
	}
	return nil
}

func (bbp *MsgpackComparison) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.INT0 = iohelp.ReadUint8Bytes(buf[at:])
	at += 1
	bbp.INT1 = iohelp.ReadUint8Bytes(buf[at:])
	at += 1
	bbp.INT1_ = iohelp.ReadInt16Bytes(buf[at:])
	at += 2
	bbp.INT8 = iohelp.ReadUint8Bytes(buf[at:])
	at += 1
	bbp.INT8_ = iohelp.ReadInt16Bytes(buf[at:])
	at += 2
	bbp.INT16 = iohelp.ReadInt16Bytes(buf[at:])
	at += 2
	bbp.INT16_ = iohelp.ReadInt16Bytes(buf[at:])
	at += 2
	bbp.INT32 = iohelp.ReadInt32Bytes(buf[at:])
	at += 4
	bbp.INT32_ = iohelp.ReadInt32Bytes(buf[at:])
	at += 4
	bbp.TRUE = iohelp.ReadBoolBytes(buf[at:])
	at += 1
	bbp.FALSE = iohelp.ReadBoolBytes(buf[at:])
	at += 1
	bbp.FLOAT = iohelp.ReadFloat64Bytes(buf[at:])
	at += 8
	bbp.FLOAT_ = iohelp.ReadFloat64Bytes(buf[at:])
	at += 8
	bbp.STRING0 = iohelp.MustReadStringBytes(buf[at:])
	at += 4+len(bbp.STRING0)
	bbp.STRING1 = iohelp.MustReadStringBytes(buf[at:])
	at += 4+len(bbp.STRING1)
	bbp.STRING4 = iohelp.MustReadStringBytes(buf[at:])
	at += 4+len(bbp.STRING4)
	bbp.STRING8 = iohelp.MustReadStringBytes(buf[at:])
	at += 4+len(bbp.STRING8)
	bbp.STRING16 = iohelp.MustReadStringBytes(buf[at:])
	at += 4+len(bbp.STRING16)
	bbp.ARRAY0 = make([]int32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.ARRAY0 {
		(bbp.ARRAY0)[i1] = iohelp.ReadInt32Bytes(buf[at:])
		at += 4
	}
	bbp.ARRAY1 = make([]string, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.ARRAY1 {
		(bbp.ARRAY1)[i1] = iohelp.MustReadStringBytes(buf[at:])
		at += 4+len((bbp.ARRAY1)[i1])
	}
	bbp.ARRAY8 = make([]int32, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.ARRAY8 {
		(bbp.ARRAY8)[i1] = iohelp.ReadInt32Bytes(buf[at:])
		at += 4
	}
}

func (bbp MsgpackComparison) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint8(w, bbp.INT0)
	iohelp.WriteUint8(w, bbp.INT1)
	iohelp.WriteInt16(w, bbp.INT1_)
	iohelp.WriteUint8(w, bbp.INT8)
	iohelp.WriteInt16(w, bbp.INT8_)
	iohelp.WriteInt16(w, bbp.INT16)
	iohelp.WriteInt16(w, bbp.INT16_)
	iohelp.WriteInt32(w, bbp.INT32)
	iohelp.WriteInt32(w, bbp.INT32_)
	iohelp.WriteBool(w, bbp.TRUE)
	iohelp.WriteBool(w, bbp.FALSE)
	iohelp.WriteFloat64(w, bbp.FLOAT)
	iohelp.WriteFloat64(w, bbp.FLOAT_)
	iohelp.WriteUint32(w, uint32(len(bbp.STRING0)))
	w.Write([]byte(bbp.STRING0))
	iohelp.WriteUint32(w, uint32(len(bbp.STRING1)))
	w.Write([]byte(bbp.STRING1))
	iohelp.WriteUint32(w, uint32(len(bbp.STRING4)))
	w.Write([]byte(bbp.STRING4))
	iohelp.WriteUint32(w, uint32(len(bbp.STRING8)))
	w.Write([]byte(bbp.STRING8))
	iohelp.WriteUint32(w, uint32(len(bbp.STRING16)))
	w.Write([]byte(bbp.STRING16))
	iohelp.WriteUint32(w, uint32(len(bbp.ARRAY0)))
	for _, elem := range bbp.ARRAY0 {
		iohelp.WriteInt32(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.ARRAY1)))
	for _, elem := range bbp.ARRAY1 {
		iohelp.WriteUint32(w, uint32(len(elem)))
		w.Write([]byte(elem))
	}
	iohelp.WriteUint32(w, uint32(len(bbp.ARRAY8)))
	for _, elem := range bbp.ARRAY8 {
		iohelp.WriteInt32(w, elem)
	}
	return w.Err
}

func (bbp *MsgpackComparison) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.INT0 = iohelp.ReadUint8(r)
	bbp.INT1 = iohelp.ReadUint8(r)
	bbp.INT1_ = iohelp.ReadInt16(r)
	bbp.INT8 = iohelp.ReadUint8(r)
	bbp.INT8_ = iohelp.ReadInt16(r)
	bbp.INT16 = iohelp.ReadInt16(r)
	bbp.INT16_ = iohelp.ReadInt16(r)
	bbp.INT32 = iohelp.ReadInt32(r)
	bbp.INT32_ = iohelp.ReadInt32(r)
	bbp.TRUE = iohelp.ReadBool(r)
	bbp.FALSE = iohelp.ReadBool(r)
	bbp.FLOAT = iohelp.ReadFloat64(r)
	bbp.FLOAT_ = iohelp.ReadFloat64(r)
	bbp.STRING0 = iohelp.ReadString(r)
	bbp.STRING1 = iohelp.ReadString(r)
	bbp.STRING4 = iohelp.ReadString(r)
	bbp.STRING8 = iohelp.ReadString(r)
	bbp.STRING16 = iohelp.ReadString(r)
	bbp.ARRAY0 = make([]int32, iohelp.ReadUint32(r))
	for i1 := range bbp.ARRAY0 {
		(bbp.ARRAY0[i1]) = iohelp.ReadInt32(r)
	}
	bbp.ARRAY1 = make([]string, iohelp.ReadUint32(r))
	for i1 := range bbp.ARRAY1 {
		(bbp.ARRAY1[i1]) = iohelp.ReadString(r)
	}
	bbp.ARRAY8 = make([]int32, iohelp.ReadUint32(r))
	for i1 := range bbp.ARRAY8 {
		(bbp.ARRAY8[i1]) = iohelp.ReadInt32(r)
	}
	return r.Err
}

func (bbp MsgpackComparison) bodyLen() int {
	bodyLen := 0
	bodyLen += 1
	bodyLen += 1
	bodyLen += 2
	bodyLen += 1
	bodyLen += 2
	bodyLen += 2
	bodyLen += 2
	bodyLen += 4
	bodyLen += 4
	bodyLen += 1
	bodyLen += 1
	bodyLen += 8
	bodyLen += 8
	bodyLen += 4
	bodyLen += len(bbp.STRING0)
	bodyLen += 4
	bodyLen += len(bbp.STRING1)
	bodyLen += 4
	bodyLen += len(bbp.STRING4)
	bodyLen += 4
	bodyLen += len(bbp.STRING8)
	bodyLen += 4
	bodyLen += len(bbp.STRING16)
	bodyLen += 4
	bodyLen += len(bbp.ARRAY0) * 4
	bodyLen += 4
	for _, elem := range bbp.ARRAY1 {
		bodyLen += 4
		bodyLen += len(elem)
	}
	bodyLen += 4
	bodyLen += len(bbp.ARRAY8) * 4
	return bodyLen
}

func makeMsgpackComparison(r iohelp.ErrorReader) (MsgpackComparison, error) {
	v := MsgpackComparison{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeMsgpackComparisonFromBytes(buf []byte) (MsgpackComparison, error) {
	v := MsgpackComparison{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeMsgpackComparisonFromBytes(buf []byte) MsgpackComparison {
	v := MsgpackComparison{}
	v.MustUnmarshalBebop(buf)
	return v
}

