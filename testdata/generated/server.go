// Code generated by bebopc-go; DO NOT EDIT.

package generated

import (
	"bytes"
	"io"

	"github.com/200sc/bebop"
	"github.com/200sc/bebop/iohelp"
)

var _ bebop.Record = &Print{}

type Print struct {
	Printout string
}

func (bbp Print) MarshalBebop() []byte {
	buf := make([]byte, bbp.bodyLen())
	bbp.MarshalBebopTo(buf)
	return buf
}

func (bbp Print) MarshalBebopTo(buf []byte) {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Printout)))
	at += 4
	copy(buf[at:at+len(bbp.Printout)], []byte(bbp.Printout))
	at += len(bbp.Printout)
}

func (bbp *Print) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	bbp.Printout, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		 return err
	}
	at += 4 + len(bbp.Printout)
	return nil
}

func (bbp *Print) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.Printout = iohelp.MustReadStringBytes(buf[at:])
	at += 4+len(bbp.Printout)
}

func (bbp Print) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.Printout)))
	w.Write([]byte(bbp.Printout))
	return w.Err
}

func (bbp *Print) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.Printout = iohelp.ReadString(r)
	return r.Err
}

func (bbp Print) bodyLen() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.Printout)
	return bodyLen
}

func makePrint(r iohelp.ErrorReader) (Print, error) {
	v := Print{}
	err := v.DecodeBebop(r)
	return v, err
}

func makePrintFromBytes(buf []byte) (Print, error) {
	v := Print{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakePrintFromBytes(buf []byte) Print {
	v := Print{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &Add{}

type Add struct {
	A int32
	B int32
}

func (bbp Add) MarshalBebop() []byte {
	buf := make([]byte, bbp.bodyLen())
	bbp.MarshalBebopTo(buf)
	return buf
}

func (bbp Add) MarshalBebopTo(buf []byte) {
	at := 0
	iohelp.WriteInt32Bytes(buf[at:], bbp.A)
	at += 4
	iohelp.WriteInt32Bytes(buf[at:], bbp.B)
	at += 4
}

func (bbp *Add) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.A = iohelp.ReadInt32Bytes(buf[at:])
	at += 4
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.B = iohelp.ReadInt32Bytes(buf[at:])
	at += 4
	return nil
}

func (bbp *Add) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.A = iohelp.ReadInt32Bytes(buf[at:])
	at += 4
	bbp.B = iohelp.ReadInt32Bytes(buf[at:])
	at += 4
}

func (bbp Add) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteInt32(w, bbp.A)
	iohelp.WriteInt32(w, bbp.B)
	return w.Err
}

func (bbp *Add) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.A = iohelp.ReadInt32(r)
	bbp.B = iohelp.ReadInt32(r)
	return r.Err
}

func (bbp Add) bodyLen() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += 4
	return bodyLen
}

func makeAdd(r iohelp.ErrorReader) (Add, error) {
	v := Add{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeAddFromBytes(buf []byte) (Add, error) {
	v := Add{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeAddFromBytes(buf []byte) Add {
	v := Add{}
	v.MustUnmarshalBebop(buf)
	return v
}

var _ bebop.Record = &AddResponse{}

type AddResponse struct {
	C int32
}

func (bbp AddResponse) MarshalBebop() []byte {
	buf := make([]byte, bbp.bodyLen())
	bbp.MarshalBebopTo(buf)
	return buf
}

func (bbp AddResponse) MarshalBebopTo(buf []byte) {
	at := 0
	iohelp.WriteInt32Bytes(buf[at:], bbp.C)
	at += 4
}

func (bbp *AddResponse) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		 return iohelp.ErrTooShort
	}
	bbp.C = iohelp.ReadInt32Bytes(buf[at:])
	at += 4
	return nil
}

func (bbp *AddResponse) MustUnmarshalBebop(buf []byte) {
	at := 0
	bbp.C = iohelp.ReadInt32Bytes(buf[at:])
	at += 4
}

func (bbp AddResponse) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteInt32(w, bbp.C)
	return w.Err
}

func (bbp *AddResponse) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.C = iohelp.ReadInt32(r)
	return r.Err
}

func (bbp AddResponse) bodyLen() int {
	bodyLen := 0
	bodyLen += 4
	return bodyLen
}

func makeAddResponse(r iohelp.ErrorReader) (AddResponse, error) {
	v := AddResponse{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeAddResponseFromBytes(buf []byte) (AddResponse, error) {
	v := AddResponse{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeAddResponseFromBytes(buf []byte) AddResponse {
	v := AddResponse{}
	v.MustUnmarshalBebop(buf)
	return v
}

const PrintRequestOpCode = 0x2

var _ bebop.Record = &PrintRequest{}

type PrintRequest struct {
	Print *Print
}

func (bbp PrintRequest) MarshalBebop() []byte {
	buf := make([]byte, bbp.bodyLen())
	bbp.MarshalBebopTo(buf)
	return buf
}

func (bbp PrintRequest) MarshalBebopTo(buf []byte) {
	iohelp.WriteUint32Bytes(buf, uint32(PrintRequestOpCode))
	at := 4
	iohelp.WriteUint32Bytes(buf[at:], uint32(bbp.bodyLen()-8))
	at += 4
	if bbp.Print != nil {
		buf[at] = 1
		at++
		(*bbp.Print).MarshalBebopTo(buf[at:])
		at += (*bbp.Print).bodyLen()
	}
}

func (bbp *PrintRequest) UnmarshalBebop(buf []byte) (err error) {
	at := 4
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.Print = new(Print)
			(*bbp.Print), err = makePrintFromBytes(buf[at:])
			if err != nil {
				 return err
			}
			at += ((*bbp.Print)).bodyLen()
		default:
			return nil
		}
	}
}

func (bbp *PrintRequest) MustUnmarshalBebop(buf []byte) {
	at := 4
	for {
		switch buf[at] {
		case 1:
			bbp.Print = new(Print)
			(*bbp.Print) = mustMakePrintFromBytes(buf[at:])
			at += ((*bbp.Print)).bodyLen()
		default:
			return
		}
	}
}

func (bbp PrintRequest) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(PrintRequestOpCode))
	iohelp.WriteUint32(w, uint32(bbp.bodyLen()-8))
	if bbp.Print != nil {
		w.Write([]byte{1})
		err = (*bbp.Print).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *PrintRequest) DecodeBebop(ior io.Reader) (err error) {
	er := iohelp.NewErrorReader(ior)
	iohelp.ReadUint32(er)
	bodyLen := iohelp.ReadUint32(er)
	body := make([]byte, bodyLen)
	er.Read(body)
	r := iohelp.NewErrorReader(bytes.NewReader(body))
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.Print = new(Print)
			(*bbp.Print), err = makePrint(r)
			if err != nil {
				return err
			}
		default:
			return er.Err
		}
	}
}

func (bbp PrintRequest) bodyLen() int {
	bodyLen := 5
	bodyLen += 4
	if bbp.Print != nil {
		bodyLen += 1
		bodyLen += (*bbp.Print).bodyLen()
	}
	return bodyLen
}

func makePrintRequest(r iohelp.ErrorReader) (PrintRequest, error) {
	v := PrintRequest{}
	err := v.DecodeBebop(r)
	return v, err
}

func makePrintRequestFromBytes(buf []byte) (PrintRequest, error) {
	v := PrintRequest{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakePrintRequestFromBytes(buf []byte) PrintRequest {
	v := PrintRequest{}
	v.MustUnmarshalBebop(buf)
	return v
}

const AddRequestOpCode = 0x1

var _ bebop.Record = &AddRequest{}

type AddRequest struct {
	Add *Add
}

func (bbp AddRequest) MarshalBebop() []byte {
	buf := make([]byte, bbp.bodyLen())
	bbp.MarshalBebopTo(buf)
	return buf
}

func (bbp AddRequest) MarshalBebopTo(buf []byte) {
	iohelp.WriteUint32Bytes(buf, uint32(AddRequestOpCode))
	at := 4
	iohelp.WriteUint32Bytes(buf[at:], uint32(bbp.bodyLen()-8))
	at += 4
	if bbp.Add != nil {
		buf[at] = 1
		at++
		(*bbp.Add).MarshalBebopTo(buf[at:])
		at += (*bbp.Add).bodyLen()
	}
}

func (bbp *AddRequest) UnmarshalBebop(buf []byte) (err error) {
	at := 4
	_ = iohelp.ReadUint32Bytes(buf[at:])
	buf = buf[4:]
	for {
		switch buf[at] {
		case 1:
			at += 1
			bbp.Add = new(Add)
			(*bbp.Add), err = makeAddFromBytes(buf[at:])
			if err != nil {
				 return err
			}
			at += ((*bbp.Add)).bodyLen()
		default:
			return nil
		}
	}
}

func (bbp *AddRequest) MustUnmarshalBebop(buf []byte) {
	at := 4
	for {
		switch buf[at] {
		case 1:
			bbp.Add = new(Add)
			(*bbp.Add) = mustMakeAddFromBytes(buf[at:])
			at += ((*bbp.Add)).bodyLen()
		default:
			return
		}
	}
}

func (bbp AddRequest) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(AddRequestOpCode))
	iohelp.WriteUint32(w, uint32(bbp.bodyLen()-8))
	if bbp.Add != nil {
		w.Write([]byte{1})
		err = (*bbp.Add).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	w.Write([]byte{0})
	return w.Err
}

func (bbp *AddRequest) DecodeBebop(ior io.Reader) (err error) {
	er := iohelp.NewErrorReader(ior)
	iohelp.ReadUint32(er)
	bodyLen := iohelp.ReadUint32(er)
	body := make([]byte, bodyLen)
	er.Read(body)
	r := iohelp.NewErrorReader(bytes.NewReader(body))
	for {
		switch iohelp.ReadByte(r) {
		case 1:
			bbp.Add = new(Add)
			(*bbp.Add), err = makeAdd(r)
			if err != nil {
				return err
			}
		default:
			return er.Err
		}
	}
}

func (bbp AddRequest) bodyLen() int {
	bodyLen := 5
	bodyLen += 4
	if bbp.Add != nil {
		bodyLen += 1
		bodyLen += (*bbp.Add).bodyLen()
	}
	return bodyLen
}

func makeAddRequest(r iohelp.ErrorReader) (AddRequest, error) {
	v := AddRequest{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeAddRequestFromBytes(buf []byte) (AddRequest, error) {
	v := AddRequest{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

func mustMakeAddRequestFromBytes(buf []byte) AddRequest {
	v := AddRequest{}
	v.MustUnmarshalBebop(buf)
	return v
}

